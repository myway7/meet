/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (function() { // webpackBootstrap
/******/ 	// runtime can't be in strict mode because a global variable is assign and maybe created.
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs":
/*!*************************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nvar loglevel = {exports: {}};\n\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/\n(function (module) {\n  (function (root, definition) {\n\n    if (module.exports) {\n      module.exports = definition();\n    } else {\n      root.log = definition();\n    }\n  })(commonjsGlobal, function () {\n\n    // Slightly dubious tricks to cut down minimized file size\n    var noop = function () {};\n    var undefinedType = \"undefined\";\n    var isIE = typeof window !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n    var logMethods = [\"trace\", \"debug\", \"info\", \"warn\", \"error\"];\n\n    // Cross-browser bind equivalent that works at least back to IE6\n    function bindMethod(obj, methodName) {\n      var method = obj[methodName];\n      if (typeof method.bind === 'function') {\n        return method.bind(obj);\n      } else {\n        try {\n          return Function.prototype.bind.call(method, obj);\n        } catch (e) {\n          // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n          return function () {\n            return Function.prototype.apply.apply(method, [obj, arguments]);\n          };\n        }\n      }\n    }\n\n    // Trace() doesn't print the message in IE, so for that case we need to wrap it\n    function traceForIE() {\n      if (console.log) {\n        if (console.log.apply) {\n          console.log.apply(console, arguments);\n        } else {\n          // In old IE, native console methods themselves don't have apply().\n          Function.prototype.apply.apply(console.log, [console, arguments]);\n        }\n      }\n      if (console.trace) console.trace();\n    }\n\n    // Build the best logging method possible for this env\n    // Wherever possible we want to bind, not wrap, to preserve stack traces\n    function realMethod(methodName) {\n      if (methodName === 'debug') {\n        methodName = 'log';\n      }\n      if (typeof console === undefinedType) {\n        return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n      } else if (methodName === 'trace' && isIE) {\n        return traceForIE;\n      } else if (console[methodName] !== undefined) {\n        return bindMethod(console, methodName);\n      } else if (console.log !== undefined) {\n        return bindMethod(console, 'log');\n      } else {\n        return noop;\n      }\n    }\n\n    // These private functions always need `this` to be set properly\n\n    function replaceLoggingMethods(level, loggerName) {\n      /*jshint validthis:true */\n      for (var i = 0; i < logMethods.length; i++) {\n        var methodName = logMethods[i];\n        this[methodName] = i < level ? noop : this.methodFactory(methodName, level, loggerName);\n      }\n\n      // Define log.log as an alias for log.debug\n      this.log = this.debug;\n    }\n\n    // In old IE versions, the console isn't present until you first open it.\n    // We build realMethod() replacements here that regenerate logging methods\n    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {\n      return function () {\n        if (typeof console !== undefinedType) {\n          replaceLoggingMethods.call(this, level, loggerName);\n          this[methodName].apply(this, arguments);\n        }\n      };\n    }\n\n    // By default, we use closely bound real methods wherever possible, and\n    // otherwise we wait for a console to appear, and then try again.\n    function defaultMethodFactory(methodName, level, loggerName) {\n      /*jshint validthis:true */\n      return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n    }\n    function Logger(name, defaultLevel, factory) {\n      var self = this;\n      var currentLevel;\n      defaultLevel = defaultLevel == null ? \"WARN\" : defaultLevel;\n      var storageKey = \"loglevel\";\n      if (typeof name === \"string\") {\n        storageKey += \":\" + name;\n      } else if (typeof name === \"symbol\") {\n        storageKey = undefined;\n      }\n      function persistLevelIfPossible(levelNum) {\n        var levelName = (logMethods[levelNum] || 'silent').toUpperCase();\n        if (typeof window === undefinedType || !storageKey) return;\n\n        // Use localStorage if available\n        try {\n          window.localStorage[storageKey] = levelName;\n          return;\n        } catch (ignore) {}\n\n        // Use session cookie as fallback\n        try {\n          window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n        } catch (ignore) {}\n      }\n      function getPersistedLevel() {\n        var storedLevel;\n        if (typeof window === undefinedType || !storageKey) return;\n        try {\n          storedLevel = window.localStorage[storageKey];\n        } catch (ignore) {}\n\n        // Fallback to cookies if local storage gives us nothing\n        if (typeof storedLevel === undefinedType) {\n          try {\n            var cookie = window.document.cookie;\n            var location = cookie.indexOf(encodeURIComponent(storageKey) + \"=\");\n            if (location !== -1) {\n              storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];\n            }\n          } catch (ignore) {}\n        }\n\n        // If the stored level is not valid, treat it as if nothing was stored.\n        if (self.levels[storedLevel] === undefined) {\n          storedLevel = undefined;\n        }\n        return storedLevel;\n      }\n      function clearPersistedLevel() {\n        if (typeof window === undefinedType || !storageKey) return;\n\n        // Use localStorage if available\n        try {\n          window.localStorage.removeItem(storageKey);\n          return;\n        } catch (ignore) {}\n\n        // Use session cookie as fallback\n        try {\n          window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n        } catch (ignore) {}\n      }\n\n      /*\n       *\n       * Public logger API - see https://github.com/pimterry/loglevel for details\n       *\n       */\n\n      self.name = name;\n      self.levels = {\n        \"TRACE\": 0,\n        \"DEBUG\": 1,\n        \"INFO\": 2,\n        \"WARN\": 3,\n        \"ERROR\": 4,\n        \"SILENT\": 5\n      };\n      self.methodFactory = factory || defaultMethodFactory;\n      self.getLevel = function () {\n        return currentLevel;\n      };\n      self.setLevel = function (level, persist) {\n        if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n          level = self.levels[level.toUpperCase()];\n        }\n        if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n          currentLevel = level;\n          if (persist !== false) {\n            // defaults to true\n            persistLevelIfPossible(level);\n          }\n          replaceLoggingMethods.call(self, level, name);\n          if (typeof console === undefinedType && level < self.levels.SILENT) {\n            return \"No console available for logging\";\n          }\n        } else {\n          throw \"log.setLevel() called with invalid level: \" + level;\n        }\n      };\n      self.setDefaultLevel = function (level) {\n        defaultLevel = level;\n        if (!getPersistedLevel()) {\n          self.setLevel(level, false);\n        }\n      };\n      self.resetLevel = function () {\n        self.setLevel(defaultLevel, false);\n        clearPersistedLevel();\n      };\n      self.enableAll = function (persist) {\n        self.setLevel(self.levels.TRACE, persist);\n      };\n      self.disableAll = function (persist) {\n        self.setLevel(self.levels.SILENT, persist);\n      };\n\n      // Initialize with the right level\n      var initialLevel = getPersistedLevel();\n      if (initialLevel == null) {\n        initialLevel = defaultLevel;\n      }\n      self.setLevel(initialLevel, false);\n    }\n\n    /*\n     *\n     * Top-level API\n     *\n     */\n\n    var defaultLogger = new Logger();\n    var _loggersByName = {};\n    defaultLogger.getLogger = function getLogger(name) {\n      if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n        throw new TypeError(\"You must supply a name when creating a logger.\");\n      }\n      var logger = _loggersByName[name];\n      if (!logger) {\n        logger = _loggersByName[name] = new Logger(name, defaultLogger.getLevel(), defaultLogger.methodFactory);\n      }\n      return logger;\n    };\n\n    // Grab the current global log variable in case of overwrite\n    var _log = typeof window !== undefinedType ? window.log : undefined;\n    defaultLogger.noConflict = function () {\n      if (typeof window !== undefinedType && window.log === defaultLogger) {\n        window.log = _log;\n      }\n      return defaultLogger;\n    };\n    defaultLogger.getLoggers = function getLoggers() {\n      return _loggersByName;\n    };\n\n    // ES6 default export, for compatibility\n    defaultLogger['default'] = defaultLogger;\n    return defaultLogger;\n  });\n})(loglevel);\nvar loglevelExports = loglevel.exports;\n\nvar LogLevel;\n(function (LogLevel) {\n  LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n  LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n  LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n  LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n  LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n  LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nconst livekitLogger = loglevelExports.getLogger('livekit');\nlivekitLogger.setDefaultLevel(LogLevel.info);\n\nconst workerLogger = loglevelExports.getLogger('lk-e2ee');\n\nconst ENCRYPTION_ALGORITHM = 'AES-GCM';\n// We use a ringbuffer of keys so we can change them and still decode packets that were\n// encrypted with an old key. We use a size of 16 which corresponds to the four bits\n// in the frame trailer.\nconst KEYRING_SIZE = 16;\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// We copy the first bytes of the VP8 payload unencrypted.\n// For keyframes this is 10 bytes, for non-keyframes (delta) 3. See\n//   https://tools.ietf.org/html/rfc6386#section-9.1\n// This allows the bridge to continue detecting keyframes (only one byte needed in the JVB)\n// and is also a bit easier for the VP8 decoder (i.e. it generates funny garbage pictures\n// instead of being unable to decode).\n// This is a bit for show and we might want to reduce to 1 unconditionally in the final version.\n//\n// For audio (where frame.type is not set) we do not encrypt the opus TOC byte:\n//   https://tools.ietf.org/html/rfc6716#section-3.1\nconst UNENCRYPTED_BYTES = {\n  key: 10,\n  delta: 3,\n  audio: 1,\n  empty: 0\n};\n/* We use a 12 byte bit IV. This is signalled in plain together with the\n packet. See https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters */\nconst IV_LENGTH = 12;\nconst SALT = 'LKFrameEncryptionKey';\nconst KEY_PROVIDER_DEFAULTS = {\n  sharedKey: false,\n  ratchetSalt: SALT,\n  ratchetWindowSize: 8,\n  failureTolerance: DECRYPTION_FAILURE_TOLERANCE\n};\nconst MAX_SIF_COUNT = 100;\nconst MAX_SIF_DURATION = 2000;\n\nclass LivekitError extends Error {\n  constructor(code, message) {\n    super(message || 'an error has occured');\n    this.code = code;\n  }\n}\nvar MediaDeviceFailure;\n(function (MediaDeviceFailure) {\n  // user rejected permissions\n  MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n  // device is not available\n  MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n  // device is in use. On Windows, only a single tab may get access to a device at a time.\n  MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n  MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function (MediaDeviceFailure) {\n  function getFailure(error) {\n    if (error && 'name' in error) {\n      if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n        return MediaDeviceFailure.NotFound;\n      }\n      if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n        return MediaDeviceFailure.PermissionDenied;\n      }\n      if (error.name === 'NotReadableError' || error.name === 'TrackStartError') {\n        return MediaDeviceFailure.DeviceInUse;\n      }\n      return MediaDeviceFailure.Other;\n    }\n  }\n  MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n\nvar CryptorErrorReason;\n(function (CryptorErrorReason) {\n  CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n  CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n  CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n  constructor(message) {\n    let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n    super(40, message);\n    this.reason = reason;\n  }\n}\n\nvar KeyProviderEvent;\n(function (KeyProviderEvent) {\n  KeyProviderEvent[\"SetKey\"] = \"setKey\";\n  KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n  KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function (KeyHandlerEvent) {\n  KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function (EncryptionEvent) {\n  EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n  EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function (CryptorEvent) {\n  CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\n\nvar events = {exports: {}};\n\nvar R = typeof Reflect === 'object' ? Reflect : null;\nvar ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n  return Function.prototype.apply.call(target, receiver, args);\n};\nvar ReflectOwnKeys;\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys;\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n};\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nevents.exports = EventEmitter;\nevents.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function () {\n    return defaultMaxListeners;\n  },\n  set: function (arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\nEventEmitter.init = function () {\n  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = type === 'error';\n  var events = this._events;\n  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0) er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n  if (handler === undefined) return false;\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n  }\n  return true;\n};\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n  checkListener(listener);\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type, listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] = prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n  return target;\n}\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\nEventEmitter.prototype.prependListener = function prependListener(type, listener) {\n  return _addListener(this, type, listener, true);\n};\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0) return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\nfunction _onceWrap(target, type, listener) {\n  var state = {\n    fired: false,\n    wrapFn: undefined,\n    target: target,\n    type: type,\n    listener: listener\n  };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\nEventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n  checkListener(listener);\n  this.prependListener(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener = function removeListener(type, listener) {\n  var list, events, position, i, originalListener;\n  checkListener(listener);\n  events = this._events;\n  if (events === undefined) return this;\n  list = events[type];\n  if (list === undefined) return this;\n  if (list === listener || list.listener === listener) {\n    if (--this._eventsCount === 0) this._events = Object.create(null);else {\n      delete events[type];\n      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n    }\n  } else if (typeof list !== 'function') {\n    position = -1;\n    for (i = list.length - 1; i >= 0; i--) {\n      if (list[i] === listener || list[i].listener === listener) {\n        originalListener = list[i].listener;\n        position = i;\n        break;\n      }\n    }\n    if (position < 0) return this;\n    if (position === 0) list.shift();else {\n      spliceOne(list, position);\n    }\n    if (list.length === 1) events[type] = list[0];\n    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n  }\n  return this;\n};\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n  var listeners, events, i;\n  events = this._events;\n  if (events === undefined) return this;\n\n  // not listening for removeListener, no need to emit\n  if (events.removeListener === undefined) {\n    if (arguments.length === 0) {\n      this._events = Object.create(null);\n      this._eventsCount = 0;\n    } else if (events[type] !== undefined) {\n      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n    }\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    var keys = Object.keys(events);\n    var key;\n    for (i = 0; i < keys.length; ++i) {\n      key = keys[i];\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n    return this;\n  }\n  listeners = events[type];\n  if (typeof listeners === 'function') {\n    this.removeListener(type, listeners);\n  } else if (listeners !== undefined) {\n    // LIFO order\n    for (i = listeners.length - 1; i >= 0; i--) {\n      this.removeListener(type, listeners[i]);\n    }\n  }\n  return this;\n};\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n  if (events === undefined) return [];\n  var evlistener = events[type];\n  if (evlistener === undefined) return [];\n  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\nEventEmitter.listenerCount = function (emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n  if (events !== undefined) {\n    var evlistener = events[type];\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n  return 0;\n}\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i) copy[i] = arr[i];\n  return copy;\n}\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n  list.pop();\n}\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    }\n    eventTargetAgnosticAddListener(emitter, name, resolver, {\n      once: true\n    });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, {\n        once: true\n      });\n    }\n  });\n}\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\nvar eventsExports = events.exports;\n\nvar AudioPresets;\n(function (AudioPresets) {\n  AudioPresets.telephone = {\n    maxBitrate: 12000\n  };\n  AudioPresets.speech = {\n    maxBitrate: 20000\n  };\n  AudioPresets.music = {\n    maxBitrate: 32000\n  };\n  AudioPresets.musicStereo = {\n    maxBitrate: 48000\n  };\n  AudioPresets.musicHighQuality = {\n    maxBitrate: 64000\n  };\n  AudioPresets.musicHighQualityStereo = {\n    maxBitrate: 96000\n  };\n})(AudioPresets || (AudioPresets = {}));\n\nfunction isVideoFrame(frame) {\n  return 'type' in frame;\n}\nfunction importKey(keyBytes) {\n  let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    name: ENCRYPTION_ALGORITHM\n  };\n  let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'encrypt';\n  return __awaiter(this, void 0, void 0, function* () {\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n    return crypto.subtle.importKey('raw', keyBytes, algorithm, false, usage === 'derive' ? ['deriveBits', 'deriveKey'] : ['encrypt', 'decrypt']);\n  });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n  const textEncoder = new TextEncoder();\n  const encodedSalt = textEncoder.encode(salt);\n  switch (algorithmName) {\n    case 'HKDF':\n      return {\n        name: 'HKDF',\n        salt: encodedSalt,\n        hash: 'SHA-256',\n        info: new ArrayBuffer(128)\n      };\n    case 'PBKDF2':\n      {\n        return {\n          name: 'PBKDF2',\n          salt: encodedSalt,\n          hash: 'SHA-256',\n          iterations: 100000\n        };\n      }\n    default:\n      throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n  }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */\nfunction deriveKeys(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n    // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n    const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n      name: ENCRYPTION_ALGORITHM,\n      length: 128\n    }, false, ['encrypt', 'decrypt']);\n    return {\n      material,\n      encryptionKey\n    };\n  });\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */\nfunction ratchet(material, salt) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n    return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n  });\n}\n\nclass SifGuard {\n  constructor() {\n    this.consecutiveSifCount = 0;\n    this.lastSifReceivedAt = 0;\n    this.userFramesSinceSif = 0;\n  }\n  recordSif() {\n    var _a;\n    this.consecutiveSifCount += 1;\n    (_a = this.sifSequenceStartedAt) !== null && _a !== void 0 ? _a : this.sifSequenceStartedAt = Date.now();\n    this.lastSifReceivedAt = Date.now();\n  }\n  recordUserFrame() {\n    if (this.sifSequenceStartedAt === undefined) {\n      return;\n    } else {\n      this.userFramesSinceSif += 1;\n    }\n    if (\n    // reset if we received more user frames than SIFs\n    this.userFramesSinceSif > this.consecutiveSifCount ||\n    // also reset if we got a new user frame and the latest SIF frame hasn't been updated in a while\n    Date.now() - this.lastSifReceivedAt > MAX_SIF_DURATION) {\n      this.reset();\n    }\n  }\n  isSifAllowed() {\n    return this.consecutiveSifCount < MAX_SIF_COUNT && (this.sifSequenceStartedAt === undefined || Date.now() - this.sifSequenceStartedAt < MAX_SIF_DURATION);\n  }\n  reset() {\n    this.userFramesSinceSif = 0;\n    this.consecutiveSifCount = 0;\n    this.sifSequenceStartedAt = undefined;\n  }\n}\n\nconst encryptionEnabledMap = new Map();\nclass BaseFrameCryptor extends eventsExports.EventEmitter {\n  encodeFunction(encodedFrame, controller) {\n    throw Error('not implemented for subclass');\n  }\n  decodeFunction(encodedFrame, controller) {\n    throw Error('not implemented for subclass');\n  }\n}\n/**\n * Cryptor is responsible for en-/decrypting media frames.\n * Each Cryptor instance is responsible for en-/decrypting a single mediaStreamTrack.\n */\nclass FrameCryptor extends BaseFrameCryptor {\n  constructor(opts) {\n    var _a;\n    super();\n    this.sendCounts = new Map();\n    this.keys = opts.keys;\n    this.participantIdentity = opts.participantIdentity;\n    this.rtpMap = new Map();\n    this.keyProviderOptions = opts.keyProviderOptions;\n    this.sifTrailer = (_a = opts.sifTrailer) !== null && _a !== void 0 ? _a : Uint8Array.from([]);\n    this.sifGuard = new SifGuard();\n  }\n  /**\n   * Assign a different participant to the cryptor.\n   * useful for transceiver re-use\n   * @param id\n   * @param keys\n   */\n  setParticipant(id, keys) {\n    this.participantIdentity = id;\n    this.keys = keys;\n    this.sifGuard.reset();\n  }\n  unsetParticipant() {\n    this.participantIdentity = undefined;\n  }\n  isEnabled() {\n    if (this.participantIdentity) {\n      return encryptionEnabledMap.get(this.participantIdentity);\n    } else {\n      return undefined;\n    }\n  }\n  getParticipantIdentity() {\n    return this.participantIdentity;\n  }\n  getTrackId() {\n    return this.trackId;\n  }\n  /**\n   * Update the video codec used by the mediaStreamTrack\n   * @param codec\n   */\n  setVideoCodec(codec) {\n    this.videoCodec = codec;\n  }\n  /**\n   * rtp payload type map used for figuring out codec of payload type when encoding\n   * @param map\n   */\n  setRtpMap(map) {\n    this.rtpMap = map;\n  }\n  setupTransform(operation, readable, writable, trackId, codec) {\n    if (codec) {\n      workerLogger.info('setting codec on cryptor to', {\n        codec\n      });\n      this.videoCodec = codec;\n    }\n    const transformFn = operation === 'encode' ? this.encodeFunction : this.decodeFunction;\n    const transformStream = new TransformStream({\n      transform: transformFn.bind(this)\n    });\n    readable.pipeThrough(transformStream).pipeTo(writable).catch(e => {\n      workerLogger.warn(e);\n      this.emit(CryptorEvent.Error, e instanceof CryptorError ? e : new CryptorError(e.message));\n    });\n    this.trackId = trackId;\n  }\n  setSifTrailer(trailer) {\n    this.sifTrailer = trailer;\n  }\n  /**\n   * Function that will be injected in a stream and will encrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   *\n   * The VP8 payload descriptor described in\n   * https://tools.ietf.org/html/rfc7741#section-4.2\n   * is part of the RTP packet and not part of the frame and is not controllable by us.\n   * This is fine as the SFU keeps having access to it for routing.\n   *\n   * The encrypted frame is formed as follows:\n   * 1) Find unencrypted byte length, depending on the codec, frame type and kind.\n   * 2) Form the GCM IV for the frame as described above.\n   * 3) Encrypt the rest of the frame using AES-GCM.\n   * 4) Allocate space for the encrypted frame.\n   * 5) Copy the unencrypted bytes to the start of the encrypted frame.\n   * 6) Append the ciphertext to the encrypted frame.\n   * 7) Append the IV.\n   * 8) Append a single byte for the key identifier.\n   * 9) Enqueue the encrypted frame for sending.\n   */\n  encodeFunction(encodedFrame, controller) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isEnabled() ||\n      // skip for encryption for empty dtx frames\n      encodedFrame.data.byteLength === 0) {\n        return controller.enqueue(encodedFrame);\n      }\n      const keySet = this.keys.getKeySet();\n      if (!keySet) {\n        throw new TypeError(\"key set not found for \".concat(this.participantIdentity, \" at index \").concat(this.keys.getCurrentKeyIndex()));\n      }\n      const {\n        encryptionKey\n      } = keySet;\n      const keyIndex = this.keys.getCurrentKeyIndex();\n      if (encryptionKey) {\n        const iv = this.makeIV((_a = encodedFrame.getMetadata().synchronizationSource) !== null && _a !== void 0 ? _a : -1, encodedFrame.timestamp);\n        // Thіs is not encrypted and contains the VP8 payload descriptor or the Opus TOC byte.\n        const frameHeader = new Uint8Array(encodedFrame.data, 0, this.getUnencryptedBytes(encodedFrame));\n        // Frame trailer contains the R|IV_LENGTH and key index\n        const frameTrailer = new Uint8Array(2);\n        frameTrailer[0] = IV_LENGTH;\n        frameTrailer[1] = keyIndex;\n        // Construct frame trailer. Similar to the frame header described in\n        // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n        // but we put it at the end.\n        //\n        // ---------+-------------------------+-+---------+----\n        // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n        // ---------+-------------------------+-+---------+----\n        try {\n          const cipherText = yield crypto.subtle.encrypt({\n            name: ENCRYPTION_ALGORITHM,\n            iv,\n            additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n          }, encryptionKey, new Uint8Array(encodedFrame.data, this.getUnencryptedBytes(encodedFrame)));\n          const newData = new ArrayBuffer(frameHeader.byteLength + cipherText.byteLength + iv.byteLength + frameTrailer.byteLength);\n          const newUint8 = new Uint8Array(newData);\n          newUint8.set(frameHeader); // copy first bytes.\n          newUint8.set(new Uint8Array(cipherText), frameHeader.byteLength); // add ciphertext.\n          newUint8.set(new Uint8Array(iv), frameHeader.byteLength + cipherText.byteLength); // append IV.\n          newUint8.set(frameTrailer, frameHeader.byteLength + cipherText.byteLength + iv.byteLength); // append frame trailer.\n          encodedFrame.data = newData;\n          return controller.enqueue(encodedFrame);\n        } catch (e) {\n          // TODO: surface this to the app.\n          workerLogger.error(e);\n        }\n      } else {\n        this.emit(CryptorEvent.Error, new CryptorError(\"encryption key missing for encoding\", CryptorErrorReason.MissingKey));\n      }\n    });\n  }\n  /**\n   * Function that will be injected in a stream and will decrypt the given encoded frames.\n   *\n   * @param {RTCEncodedVideoFrame|RTCEncodedAudioFrame} encodedFrame - Encoded video frame.\n   * @param {TransformStreamDefaultController} controller - TransportStreamController.\n   */\n  decodeFunction(encodedFrame, controller) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.isEnabled() ||\n      // skip for decryption for empty dtx frames\n      encodedFrame.data.byteLength === 0) {\n        this.sifGuard.recordUserFrame();\n        return controller.enqueue(encodedFrame);\n      }\n      if (isFrameServerInjected(encodedFrame.data, this.sifTrailer)) {\n        this.sifGuard.recordSif();\n        if (this.sifGuard.isSifAllowed()) {\n          encodedFrame.data = encodedFrame.data.slice(0, encodedFrame.data.byteLength - this.sifTrailer.byteLength);\n          return controller.enqueue(encodedFrame);\n        } else {\n          workerLogger.warn('SIF limit reached, dropping frame');\n          return;\n        }\n      } else {\n        this.sifGuard.recordUserFrame();\n      }\n      const data = new Uint8Array(encodedFrame.data);\n      const keyIndex = data[encodedFrame.data.byteLength - 1];\n      if (this.keys.getKeySet(keyIndex) && this.keys.hasValidKey) {\n        try {\n          const decodedFrame = yield this.decryptFrame(encodedFrame, keyIndex);\n          this.keys.decryptionSuccess();\n          if (decodedFrame) {\n            return controller.enqueue(decodedFrame);\n          }\n        } catch (error) {\n          if (error instanceof CryptorError && error.reason === CryptorErrorReason.InvalidKey) {\n            if (this.keys.hasValidKey) {\n              this.emit(CryptorEvent.Error, error);\n              this.keys.decryptionFailure();\n            }\n          } else {\n            workerLogger.warn('decoding frame failed', {\n              error\n            });\n          }\n        }\n      } else if (!this.keys.getKeySet(keyIndex) && this.keys.hasValidKey) {\n        // emit an error in case the key index is out of bounds but the key handler thinks we still have a valid key\n        workerLogger.warn('skipping decryption due to missing key at index');\n        this.emit(CryptorEvent.Error, new CryptorError(\"missing key at index for participant \".concat(this.participantIdentity), CryptorErrorReason.MissingKey));\n      }\n    });\n  }\n  /**\n   * Function that will decrypt the given encoded frame. If the decryption fails, it will\n   * ratchet the key for up to RATCHET_WINDOW_SIZE times.\n   */\n  decryptFrame(encodedFrame, keyIndex) {\n    let initialMaterial = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;\n    let ratchetOpts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {\n      ratchetCount: 0\n    };\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const keySet = this.keys.getKeySet(keyIndex);\n      if (!ratchetOpts.encryptionKey && !keySet) {\n        throw new TypeError(\"no encryption key found for decryption of \".concat(this.participantIdentity));\n      }\n      // Construct frame trailer. Similar to the frame header described in\n      // https://tools.ietf.org/html/draft-omara-sframe-00#section-4.2\n      // but we put it at the end.\n      //\n      // ---------+-------------------------+-+---------+----\n      // payload  |IV...(length = IV_LENGTH)|R|IV_LENGTH|KID |\n      // ---------+-------------------------+-+---------+----\n      try {\n        const frameHeader = new Uint8Array(encodedFrame.data, 0, this.getUnencryptedBytes(encodedFrame));\n        const frameTrailer = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - 2, 2);\n        const ivLength = frameTrailer[0];\n        const iv = new Uint8Array(encodedFrame.data, encodedFrame.data.byteLength - ivLength - frameTrailer.byteLength, ivLength);\n        const cipherTextStart = frameHeader.byteLength;\n        const cipherTextLength = encodedFrame.data.byteLength - (frameHeader.byteLength + ivLength + frameTrailer.byteLength);\n        const plainText = yield crypto.subtle.decrypt({\n          name: ENCRYPTION_ALGORITHM,\n          iv,\n          additionalData: new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength)\n        }, (_a = ratchetOpts.encryptionKey) !== null && _a !== void 0 ? _a : keySet.encryptionKey, new Uint8Array(encodedFrame.data, cipherTextStart, cipherTextLength));\n        const newData = new ArrayBuffer(frameHeader.byteLength + plainText.byteLength);\n        const newUint8 = new Uint8Array(newData);\n        newUint8.set(new Uint8Array(encodedFrame.data, 0, frameHeader.byteLength));\n        newUint8.set(new Uint8Array(plainText), frameHeader.byteLength);\n        encodedFrame.data = newData;\n        return encodedFrame;\n      } catch (error) {\n        if (this.keyProviderOptions.ratchetWindowSize > 0) {\n          if (ratchetOpts.ratchetCount < this.keyProviderOptions.ratchetWindowSize) {\n            workerLogger.debug(\"ratcheting key attempt \".concat(ratchetOpts.ratchetCount, \" of \").concat(this.keyProviderOptions.ratchetWindowSize, \", for kind \").concat(encodedFrame instanceof RTCEncodedAudioFrame ? 'audio' : 'video'));\n            let ratchetedKeySet;\n            if (keySet === this.keys.getKeySet(keyIndex)) {\n              // only ratchet if the currently set key is still the same as the one used to decrypt this frame\n              // if not, it might be that a different frame has already ratcheted and we try with that one first\n              const newMaterial = yield this.keys.ratchetKey(keyIndex, false);\n              ratchetedKeySet = yield deriveKeys(newMaterial, this.keyProviderOptions.ratchetSalt);\n            }\n            const frame = yield this.decryptFrame(encodedFrame, keyIndex, initialMaterial || keySet, {\n              ratchetCount: ratchetOpts.ratchetCount + 1,\n              encryptionKey: ratchetedKeySet === null || ratchetedKeySet === void 0 ? void 0 : ratchetedKeySet.encryptionKey\n            });\n            if (frame && ratchetedKeySet) {\n              this.keys.setKeySet(ratchetedKeySet, keyIndex, true);\n              // decryption was successful, set the new key index to reflect the ratcheted key set\n              this.keys.setCurrentKeyIndex(keyIndex);\n            }\n            return frame;\n          } else {\n            /**\n             * Since the key it is first send and only afterwards actually used for encrypting, there were\n             * situations when the decrypting failed due to the fact that the received frame was not encrypted\n             * yet and ratcheting, of course, did not solve the problem. So if we fail RATCHET_WINDOW_SIZE times,\n             * we come back to the initial key.\n             */\n            if (initialMaterial) {\n              workerLogger.debug('resetting to initial material');\n              this.keys.setKeyFromMaterial(initialMaterial.material, keyIndex);\n            }\n            workerLogger.warn('maximum ratchet attempts exceeded');\n            throw new CryptorError(\"valid key missing for participant \".concat(this.participantIdentity), CryptorErrorReason.InvalidKey);\n          }\n        } else {\n          throw new CryptorError(\"Decryption failed: \".concat(error.message), CryptorErrorReason.InvalidKey);\n        }\n      }\n    });\n  }\n  /**\n   * Construct the IV used for AES-GCM and sent (in plain) with the packet similar to\n   * https://tools.ietf.org/html/rfc7714#section-8.1\n   * It concatenates\n   * - the 32 bit synchronization source (SSRC) given on the encoded frame,\n   * - the 32 bit rtp timestamp given on the encoded frame,\n   * - a send counter that is specific to the SSRC. Starts at a random number.\n   * The send counter is essentially the pictureId but we currently have to implement this ourselves.\n   * There is no XOR with a salt. Note that this IV leaks the SSRC to the receiver but since this is\n   * randomly generated and SFUs may not rewrite this is considered acceptable.\n   * The SSRC is used to allow demultiplexing multiple streams with the same key, as described in\n   *   https://tools.ietf.org/html/rfc3711#section-4.1.1\n   * The RTP timestamp is 32 bits and advances by the codec clock rate (90khz for video, 48khz for\n   * opus audio) every second. For video it rolls over roughly every 13 hours.\n   * The send counter will advance at the frame rate (30fps for video, 50fps for 20ms opus audio)\n   * every second. It will take a long time to roll over.\n   *\n   * See also https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams\n   */\n  makeIV(synchronizationSource, timestamp) {\n    var _a;\n    const iv = new ArrayBuffer(IV_LENGTH);\n    const ivView = new DataView(iv);\n    // having to keep our own send count (similar to a picture id) is not ideal.\n    if (!this.sendCounts.has(synchronizationSource)) {\n      // Initialize with a random offset, similar to the RTP sequence number.\n      this.sendCounts.set(synchronizationSource, Math.floor(Math.random() * 0xffff));\n    }\n    const sendCount = (_a = this.sendCounts.get(synchronizationSource)) !== null && _a !== void 0 ? _a : 0;\n    ivView.setUint32(0, synchronizationSource);\n    ivView.setUint32(4, timestamp);\n    ivView.setUint32(8, timestamp - sendCount % 0xffff);\n    this.sendCounts.set(synchronizationSource, sendCount + 1);\n    return iv;\n  }\n  getUnencryptedBytes(frame) {\n    var _a;\n    if (isVideoFrame(frame)) {\n      let detectedCodec = (_a = this.getVideoCodec(frame)) !== null && _a !== void 0 ? _a : this.videoCodec;\n      if (detectedCodec === 'av1' || detectedCodec === 'vp9') {\n        throw new Error(\"\".concat(detectedCodec, \" is not yet supported for end to end encryption\"));\n      }\n      if (detectedCodec === 'vp8') {\n        return UNENCRYPTED_BYTES[frame.type];\n      }\n      const data = new Uint8Array(frame.data);\n      try {\n        const naluIndices = findNALUIndices(data);\n        // if the detected codec is undefined we test whether it _looks_ like a h264 frame as a best guess\n        const isH264 = detectedCodec === 'h264' || naluIndices.some(naluIndex => [NALUType.SLICE_IDR, NALUType.SLICE_NON_IDR].includes(parseNALUType(data[naluIndex])));\n        if (isH264) {\n          for (const index of naluIndices) {\n            let type = parseNALUType(data[index]);\n            switch (type) {\n              case NALUType.SLICE_IDR:\n              case NALUType.SLICE_NON_IDR:\n                return index + 2;\n              default:\n                break;\n            }\n          }\n          throw new TypeError('Could not find NALU');\n        }\n      } catch (e) {\n        // no op, we just continue and fallback to vp8\n      }\n      return UNENCRYPTED_BYTES[frame.type];\n    } else {\n      return UNENCRYPTED_BYTES.audio;\n    }\n  }\n  /**\n   * inspects frame payloadtype if available and maps it to the codec specified in rtpMap\n   */\n  getVideoCodec(frame) {\n    if (this.rtpMap.size === 0) {\n      return undefined;\n    }\n    // @ts-expect-error payloadType is not yet part of the typescript definition and currently not supported in Safari\n    const payloadType = frame.getMetadata().payloadType;\n    const codec = payloadType ? this.rtpMap.get(payloadType) : undefined;\n    return codec;\n  }\n}\n/**\n * Slice the NALUs present in the supplied buffer, assuming it is already byte-aligned\n * code adapted from https://github.com/medooze/h264-frame-parser/blob/main/lib/NalUnits.ts to return indices only\n */\nfunction findNALUIndices(stream) {\n  const result = [];\n  let start = 0,\n    pos = 0,\n    searchLength = stream.length - 2;\n  while (pos < searchLength) {\n    // skip until end of current NALU\n    while (pos < searchLength && !(stream[pos] === 0 && stream[pos + 1] === 0 && stream[pos + 2] === 1)) pos++;\n    if (pos >= searchLength) pos = stream.length;\n    // remove trailing zeros from current NALU\n    let end = pos;\n    while (end > start && stream[end - 1] === 0) end--;\n    // save current NALU\n    if (start === 0) {\n      if (end !== start) throw TypeError('byte stream contains leading data');\n    } else {\n      result.push(start);\n    }\n    // begin new NALU\n    start = pos = pos + 3;\n  }\n  return result;\n}\nfunction parseNALUType(startByte) {\n  return startByte & kNaluTypeMask;\n}\nconst kNaluTypeMask = 0x1f;\nvar NALUType;\n(function (NALUType) {\n  /** Coded slice of a non-IDR picture */\n  NALUType[NALUType[\"SLICE_NON_IDR\"] = 1] = \"SLICE_NON_IDR\";\n  /** Coded slice data partition A */\n  NALUType[NALUType[\"SLICE_PARTITION_A\"] = 2] = \"SLICE_PARTITION_A\";\n  /** Coded slice data partition B */\n  NALUType[NALUType[\"SLICE_PARTITION_B\"] = 3] = \"SLICE_PARTITION_B\";\n  /** Coded slice data partition C */\n  NALUType[NALUType[\"SLICE_PARTITION_C\"] = 4] = \"SLICE_PARTITION_C\";\n  /** Coded slice of an IDR picture */\n  NALUType[NALUType[\"SLICE_IDR\"] = 5] = \"SLICE_IDR\";\n  /** Supplemental enhancement information */\n  NALUType[NALUType[\"SEI\"] = 6] = \"SEI\";\n  /** Sequence parameter set */\n  NALUType[NALUType[\"SPS\"] = 7] = \"SPS\";\n  /** Picture parameter set */\n  NALUType[NALUType[\"PPS\"] = 8] = \"PPS\";\n  /** Access unit delimiter */\n  NALUType[NALUType[\"AUD\"] = 9] = \"AUD\";\n  /** End of sequence */\n  NALUType[NALUType[\"END_SEQ\"] = 10] = \"END_SEQ\";\n  /** End of stream */\n  NALUType[NALUType[\"END_STREAM\"] = 11] = \"END_STREAM\";\n  /** Filler data */\n  NALUType[NALUType[\"FILLER_DATA\"] = 12] = \"FILLER_DATA\";\n  /** Sequence parameter set extension */\n  NALUType[NALUType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n  /** Prefix NAL unit */\n  NALUType[NALUType[\"PREFIX_NALU\"] = 14] = \"PREFIX_NALU\";\n  /** Subset sequence parameter set */\n  NALUType[NALUType[\"SUBSET_SPS\"] = 15] = \"SUBSET_SPS\";\n  /** Depth parameter set */\n  NALUType[NALUType[\"DPS\"] = 16] = \"DPS\";\n  // 17, 18 reserved\n  /** Coded slice of an auxiliary coded picture without partitioning */\n  NALUType[NALUType[\"SLICE_AUX\"] = 19] = \"SLICE_AUX\";\n  /** Coded slice extension */\n  NALUType[NALUType[\"SLICE_EXT\"] = 20] = \"SLICE_EXT\";\n  /** Coded slice extension for a depth view component or a 3D-AVC texture view component */\n  NALUType[NALUType[\"SLICE_LAYER_EXT\"] = 21] = \"SLICE_LAYER_EXT\";\n  // 22, 23 reserved\n})(NALUType || (NALUType = {}));\n/**\n * we use a magic frame trailer to detect whether a frame is injected\n * by the livekit server and thus to be treated as unencrypted\n * @internal\n */\nfunction isFrameServerInjected(frameData, trailerBytes) {\n  if (trailerBytes.byteLength === 0) {\n    return false;\n  }\n  const frameTrailer = new Uint8Array(frameData.slice(frameData.byteLength - trailerBytes.byteLength));\n  return trailerBytes.every((value, index) => value === frameTrailer[index]);\n}\n\n// TODO ParticipantKeyHandlers currently don't get destroyed on participant disconnect\n// we could do this by having a separate worker message on participant disconnected.\n/**\n * ParticipantKeyHandler is responsible for providing a cryptor instance with the\n * en-/decryption key of a participant. It assumes that all tracks of a specific participant\n * are encrypted with the same key.\n * Additionally it exposes a method to ratchet a key which can be used by the cryptor either automatically\n * if decryption fails or can be triggered manually on both sender and receiver side.\n *\n */\nclass ParticipantKeyHandler extends eventsExports.EventEmitter {\n  get hasValidKey() {\n    return this._hasValidKey;\n  }\n  constructor(participantIdentity, keyProviderOptions) {\n    super();\n    this.decryptionFailureCount = 0;\n    this._hasValidKey = true;\n    this.currentKeyIndex = 0;\n    this.cryptoKeyRing = new Array(KEYRING_SIZE).fill(undefined);\n    this.keyProviderOptions = keyProviderOptions;\n    this.ratchetPromiseMap = new Map();\n    this.participantIdentity = participantIdentity;\n    this.resetKeyStatus();\n  }\n  decryptionFailure() {\n    if (this.keyProviderOptions.failureTolerance < 0) {\n      return;\n    }\n    this.decryptionFailureCount += 1;\n    if (this.decryptionFailureCount > this.keyProviderOptions.failureTolerance) {\n      workerLogger.warn(\"key for \".concat(this.participantIdentity, \" is being marked as invalid\"));\n      this._hasValidKey = false;\n    }\n  }\n  decryptionSuccess() {\n    this.resetKeyStatus();\n  }\n  /**\n   * Call this after user initiated ratchet or a new key has been set in order to make sure to mark potentially\n   * invalid keys as valid again\n   */\n  resetKeyStatus() {\n    this.decryptionFailureCount = 0;\n    this._hasValidKey = true;\n  }\n  /**\n   * Ratchets the current key (or the one at keyIndex if provided) and\n   * returns the ratcheted material\n   * if `setKey` is true (default), it will also set the ratcheted key directly on the crypto key ring\n   * @param keyIndex\n   * @param setKey\n   */\n  ratchetKey(keyIndex) {\n    let setKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    const currentKeyIndex = keyIndex !== null && keyIndex !== void 0 ? keyIndex : this.getCurrentKeyIndex();\n    const existingPromise = this.ratchetPromiseMap.get(currentKeyIndex);\n    if (typeof existingPromise !== 'undefined') {\n      return existingPromise;\n    }\n    const ratchetPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n      try {\n        const keySet = this.getKeySet(currentKeyIndex);\n        if (!keySet) {\n          throw new TypeError(\"Cannot ratchet key without a valid keyset of participant \".concat(this.participantIdentity));\n        }\n        const currentMaterial = keySet.material;\n        const newMaterial = yield importKey(yield ratchet(currentMaterial, this.keyProviderOptions.ratchetSalt), currentMaterial.algorithm.name, 'derive');\n        if (setKey) {\n          this.setKeyFromMaterial(newMaterial, currentKeyIndex, true);\n          this.emit(KeyHandlerEvent.KeyRatcheted, newMaterial, this.participantIdentity, currentKeyIndex);\n        }\n        resolve(newMaterial);\n      } catch (e) {\n        reject(e);\n      } finally {\n        this.ratchetPromiseMap.delete(currentKeyIndex);\n      }\n    }));\n    this.ratchetPromiseMap.set(currentKeyIndex, ratchetPromise);\n    return ratchetPromise;\n  }\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffer\n   * together with the material\n   * also resets the valid key property and updates the currentKeyIndex\n   */\n  setKey(material) {\n    let keyIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.setKeyFromMaterial(material, keyIndex);\n      this.resetKeyStatus();\n    });\n  }\n  /**\n   * takes in a key material with `deriveBits` and `deriveKey` set as key usages\n   * and derives encryption keys from the material and sets it on the key ring buffer\n   * together with the material\n   * also updates the currentKeyIndex\n   */\n  setKeyFromMaterial(material) {\n    let keyIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let emitRatchetEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    return __awaiter(this, void 0, void 0, function* () {\n      workerLogger.debug('setting new key');\n      if (keyIndex >= 0) {\n        this.currentKeyIndex = keyIndex % this.cryptoKeyRing.length;\n      }\n      const keySet = yield deriveKeys(material, this.keyProviderOptions.ratchetSalt);\n      this.setKeySet(keySet, this.currentKeyIndex, emitRatchetEvent);\n    });\n  }\n  setKeySet(keySet, keyIndex) {\n    let emitRatchetEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    this.cryptoKeyRing[keyIndex % this.cryptoKeyRing.length] = keySet;\n    if (emitRatchetEvent) {\n      this.emit(KeyHandlerEvent.KeyRatcheted, keySet.material, this.participantIdentity, keyIndex);\n    }\n  }\n  setCurrentKeyIndex(index) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.currentKeyIndex = index % this.cryptoKeyRing.length;\n      this.resetKeyStatus();\n    });\n  }\n  getCurrentKeyIndex() {\n    return this.currentKeyIndex;\n  }\n  /**\n   * returns currently used KeySet or the one at `keyIndex` if provided\n   * @param keyIndex\n   * @returns\n   */\n  getKeySet(keyIndex) {\n    return this.cryptoKeyRing[keyIndex !== null && keyIndex !== void 0 ? keyIndex : this.currentKeyIndex];\n  }\n}\n\nconst participantCryptors = [];\nconst participantKeys = new Map();\nlet sharedKeyHandler;\nlet isEncryptionEnabled = false;\nlet useSharedKey = false;\nlet sharedKey;\nlet sifTrailer;\nlet keyProviderOptions = KEY_PROVIDER_DEFAULTS;\nworkerLogger.setDefaultLevel('info');\nonmessage = ev => {\n  const {\n    kind,\n    data\n  } = ev.data;\n  switch (kind) {\n    case 'init':\n      workerLogger.info('worker initialized');\n      keyProviderOptions = data.keyProviderOptions;\n      useSharedKey = !!data.keyProviderOptions.sharedKey;\n      // acknowledge init successful\n      const ackMsg = {\n        kind: 'initAck',\n        data: {\n          enabled: isEncryptionEnabled\n        }\n      };\n      postMessage(ackMsg);\n      break;\n    case 'enable':\n      setEncryptionEnabled(data.enabled, data.participantIdentity);\n      workerLogger.info('updated e2ee enabled status');\n      // acknowledge enable call successful\n      postMessage(ev.data);\n      break;\n    case 'decode':\n      let cryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n      cryptor.setupTransform(kind, data.readableStream, data.writableStream, data.trackId, data.codec);\n      break;\n    case 'encode':\n      let pubCryptor = getTrackCryptor(data.participantIdentity, data.trackId);\n      pubCryptor.setupTransform(kind, data.readableStream, data.writableStream, data.trackId, data.codec);\n      break;\n    case 'setKey':\n      if (useSharedKey) {\n        workerLogger.warn('set shared key');\n        setSharedKey(data.key, data.keyIndex);\n      } else if (data.participantIdentity) {\n        workerLogger.warn(\"set participant sender key \".concat(data.participantIdentity));\n        getParticipantKeyHandler(data.participantIdentity).setKey(data.key, data.keyIndex);\n      } else {\n        workerLogger.error('no participant Id was provided and shared key usage is disabled');\n      }\n      break;\n    case 'removeTransform':\n      unsetCryptorParticipant(data.trackId);\n      break;\n    case 'updateCodec':\n      getTrackCryptor(data.participantIdentity, data.trackId).setVideoCodec(data.codec);\n      break;\n    case 'setRTPMap':\n      // this is only used for the local participant\n      participantCryptors.forEach(cr => {\n        if (cr.getParticipantIdentity() === data.participantIdentity) {\n          cr.setRtpMap(data.map);\n        }\n      });\n      break;\n    case 'ratchetRequest':\n      handleRatchetRequest(data);\n      break;\n    case 'setSifTrailer':\n      handleSifTrailer(data.trailer);\n      break;\n  }\n};\nfunction handleRatchetRequest(data) {\n  return __awaiter(this, void 0, void 0, function* () {\n    if (useSharedKey) {\n      const keyHandler = getSharedKeyHandler();\n      yield keyHandler.ratchetKey(data.keyIndex);\n      keyHandler.resetKeyStatus();\n    } else if (data.participantIdentity) {\n      const keyHandler = getParticipantKeyHandler(data.participantIdentity);\n      yield keyHandler.ratchetKey(data.keyIndex);\n      keyHandler.resetKeyStatus();\n    } else {\n      workerLogger.error('no participant Id was provided for ratchet request and shared key usage is disabled');\n    }\n  });\n}\nfunction getTrackCryptor(participantIdentity, trackId) {\n  let cryptor = participantCryptors.find(c => c.getTrackId() === trackId);\n  if (!cryptor) {\n    workerLogger.info('creating new cryptor for', {\n      participantIdentity\n    });\n    if (!keyProviderOptions) {\n      throw Error('Missing keyProvider options');\n    }\n    cryptor = new FrameCryptor({\n      participantIdentity,\n      keys: getParticipantKeyHandler(participantIdentity),\n      keyProviderOptions,\n      sifTrailer\n    });\n    setupCryptorErrorEvents(cryptor);\n    participantCryptors.push(cryptor);\n  } else if (participantIdentity !== cryptor.getParticipantIdentity()) {\n    // assign new participant id to track cryptor and pass in correct key handler\n    cryptor.setParticipant(participantIdentity, getParticipantKeyHandler(participantIdentity));\n  }\n  return cryptor;\n}\nfunction getParticipantKeyHandler(participantIdentity) {\n  if (useSharedKey) {\n    return getSharedKeyHandler();\n  }\n  let keys = participantKeys.get(participantIdentity);\n  if (!keys) {\n    keys = new ParticipantKeyHandler(participantIdentity, keyProviderOptions);\n    if (sharedKey) {\n      keys.setKey(sharedKey);\n    }\n    keys.on(KeyHandlerEvent.KeyRatcheted, emitRatchetedKeys);\n    participantKeys.set(participantIdentity, keys);\n  }\n  return keys;\n}\nfunction getSharedKeyHandler() {\n  if (!sharedKeyHandler) {\n    sharedKeyHandler = new ParticipantKeyHandler('shared-key', keyProviderOptions);\n  }\n  return sharedKeyHandler;\n}\nfunction unsetCryptorParticipant(trackId) {\n  var _a;\n  (_a = participantCryptors.find(c => c.getTrackId() === trackId)) === null || _a === void 0 ? void 0 : _a.unsetParticipant();\n}\nfunction setEncryptionEnabled(enable, participantIdentity) {\n  encryptionEnabledMap.set(participantIdentity, enable);\n}\nfunction setSharedKey(key, index) {\n  workerLogger.debug('setting shared key');\n  sharedKey = key;\n  getSharedKeyHandler().setKey(key, index);\n}\nfunction setupCryptorErrorEvents(cryptor) {\n  cryptor.on(CryptorEvent.Error, error => {\n    const msg = {\n      kind: 'error',\n      data: {\n        error: new Error(\"\".concat(CryptorErrorReason[error.reason], \": \").concat(error.message))\n      }\n    };\n    postMessage(msg);\n  });\n}\nfunction emitRatchetedKeys(material, participantIdentity, keyIndex) {\n  const msg = {\n    kind: \"ratchetKey\",\n    data: {\n      participantIdentity,\n      keyIndex,\n      material\n    }\n  };\n  postMessage(msg);\n}\nfunction handleSifTrailer(trailer) {\n  sifTrailer = trailer;\n  participantCryptors.forEach(c => {\n    c.setSifTrailer(trailer);\n  });\n}\n// Operations using RTCRtpScriptTransform.\n// @ts-ignore\nif (self.RTCTransformEvent) {\n  workerLogger.debug('setup transform event');\n  // @ts-ignore\n  self.onrtctransform = event => {\n    const transformer = event.transformer;\n    workerLogger.debug('transformer', transformer);\n    transformer.handled = true;\n    const {\n      kind,\n      participantIdentity,\n      trackId,\n      codec\n    } = transformer.options;\n    const cryptor = getTrackCryptor(participantIdentity, trackId);\n    workerLogger.debug('transform', {\n      codec\n    });\n    cryptor.setupTransform(kind, transformer.readable, transformer.writable, trackId, codec);\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lMmVlLndvcmtlci5tanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBTUMsQ0FBVUEsVUFBQUEsSUFBSSxFQUFFQyxVQUFVLEVBQUU7O0lBSWxCLElBQWtDQyxNQUFNLENBQUNDLE9BQU8sRUFBRTtBQUNyREQsTUFBQUEsTUFBQSxDQUFBQyxPQUFBLEdBQWlCRixVQUFVLEVBQUU7QUFDckMsS0FBSyxNQUFNO0FBQ0hELE1BQUFBLElBQUksQ0FBQ0ksR0FBRyxHQUFHSCxVQUFVLEVBQUU7QUFDMUI7QUFDTCxHQUFDLEVBQUNJLGNBQUksRUFBRSxZQUFZOztBQUdwQjtBQUNJLFFBQUlDLElBQUksR0FBRyxZQUFXLEVBQUU7SUFDeEIsSUFBSUMsYUFBYSxHQUFHLFdBQVc7SUFDL0IsSUFBSUMsSUFBSSxHQUFJLE9BQU9DLE1BQU0sS0FBS0YsYUFBYSxJQUFNLE9BQU9FLE1BQU0sQ0FBQ0MsU0FBUyxLQUFLSCxhQUFjLElBQ3ZGLGlCQUFpQixDQUFDSSxJQUFJLENBQUNGLE1BQU0sQ0FBQ0MsU0FBUyxDQUFDRSxTQUFTLENBQ3BEO0FBRUQsUUFBSUMsVUFBVSxHQUFHLENBQ2IsT0FBTyxFQUNQLE9BQU8sRUFDUCxNQUFNLEVBQ04sTUFBTSxFQUNOLE9BQU8sQ0FDVjs7QUFFTDtBQUNJLGFBQVNDLFVBQVVBLENBQUNDLEdBQUcsRUFBRUMsVUFBVSxFQUFFO0FBQ2pDLFVBQUlDLE1BQU0sR0FBR0YsR0FBRyxDQUFDQyxVQUFVLENBQUM7QUFDNUIsVUFBSSxPQUFPQyxNQUFNLENBQUNDLElBQUksS0FBSyxVQUFVLEVBQUU7QUFDbkMsZUFBT0QsTUFBTSxDQUFDQyxJQUFJLENBQUNILEdBQUcsQ0FBQztBQUNuQyxPQUFTLE1BQU07UUFDSCxJQUFJO1VBQ0EsT0FBT0ksUUFBUSxDQUFDQyxTQUFTLENBQUNGLElBQUksQ0FBQ0cs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Q0FBQ0MsV0FBVztBQUNyQ3hXLElBQUFBLFlBQVksQ0FBQ2pELEtBQUssQ0FBQyxhQUFhLEVBQUV5WixXQUFXLENBQUM7SUFDOUNBLFdBQVcsQ0FBQ0MsT0FBTyxHQUFHLElBQUk7SUFDMUIsTUFBTTtNQUFFN0IsSUFBSTtNQUFFbkksbUJBQW1CO01BQUVhLE9BQU87QUFBRUUsTUFBQUEsS0FBQUE7S0FBTyxHQUFHZ0osV0FBVyxDQUFDRSxPQUFPO0FBQ3pFLFVBQU16QixPQUFPLEdBQUdDLGVBQWUsQ0FBQ3pJLG1CQUFtQixFQUFFYSxPQUFPLENBQUM7QUFDN0R0TixJQUFBQSxZQUFZLENBQUNqRCxLQUFLLENBQUMsV0FBVyxFQUFFO0FBQUV5USxNQUFBQSxLQUFBQTtBQUFPLE1BQUM7QUFDMUN5SCxJQUFBQSxPQUFPLENBQUNySCxjQUFjLENBQUNnSCxJQUFJLEVBQUU0QixXQUFXLENBQUMxSSxRQUFRLEVBQUUwSSxXQUFXLENBQUN6SSxRQUFRLEVBQUVULE9BQU8sRUFBRUUsS0FBSyxDQUFDO0dBQ3pGO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L25vZGVfbW9kdWxlcy9sb2dsZXZlbC9saWIvbG9nbGV2ZWwuanM/ZGYxZSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9sb2dnZXIudHM/ZmUzYyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL2NvbnN0YW50cy50cz9hNGIwIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvc3JjL3Jvb20vZXJyb3JzLnRzPzFmYzMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvZTJlZS9lcnJvcnMudHM/NDdlMiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL2V2ZW50cy50cz8zNjBiIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanM/YTllMSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9yb29tL3RyYWNrL29wdGlvbnMudHM/N2NlYyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL3V0aWxzLnRzPzgyN2UiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9zcmMvZTJlZS93b3JrZXIvU2lmR3VhcmQudHM/MzA3ZSIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL3dvcmtlci9GcmFtZUNyeXB0b3IudHM/OTJmNiIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL3dvcmtlci9QYXJ0aWNpcGFudEtleUhhbmRsZXIudHM/NzNiNyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2xpdmVraXQtY2xpZW50L3NyYy9lMmVlL3dvcmtlci9lMmVlLndvcmtlci50cz81ZmJiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4qIGxvZ2xldmVsIC0gaHR0cHM6Ly9naXRodWIuY29tL3BpbXRlcnJ5L2xvZ2xldmVsXG4qXG4qIENvcHlyaWdodCAoYykgMjAxMyBUaW0gUGVycnlcbiogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuKi9cbihmdW5jdGlvbiAocm9vdCwgZGVmaW5pdGlvbikge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGRlZmluaXRpb24pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgfVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICAvLyBTbGlnaHRseSBkdWJpb3VzIHRyaWNrcyB0byBjdXQgZG93biBtaW5pbWl6ZWQgZmlsZSBzaXplXG4gICAgdmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICB2YXIgaXNJRSA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSAmJiAodHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3IgIT09IHVuZGVmaW5lZFR5cGUpICYmIChcbiAgICAgICAgL1RyaWRlbnRcXC98TVNJRSAvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgKTtcblxuICAgIHZhciBsb2dNZXRob2RzID0gW1xuICAgICAgICBcInRyYWNlXCIsXG4gICAgICAgIFwiZGVidWdcIixcbiAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgIFwid2FyblwiLFxuICAgICAgICBcImVycm9yXCJcbiAgICBdO1xuXG4gICAgLy8gQ3Jvc3MtYnJvd3NlciBiaW5kIGVxdWl2YWxlbnQgdGhhdCB3b3JrcyBhdCBsZWFzdCBiYWNrIHRvIElFNlxuICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXRob2QuYmluZChvYmopO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQuY2FsbChtZXRob2QsIG9iaik7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTWlzc2luZyBiaW5kIHNoaW0gb3IgSUU4ICsgTW9kZXJuaXpyLCBmYWxsYmFjayB0byB3cmFwcGluZ1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5hcHBseShtZXRob2QsIFtvYmosIGFyZ3VtZW50c10pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcmFjZSgpIGRvZXNuJ3QgcHJpbnQgdGhlIG1lc3NhZ2UgaW4gSUUsIHNvIGZvciB0aGF0IGNhc2Ugd2UgbmVlZCB0byB3cmFwIGl0XG4gICAgZnVuY3Rpb24gdHJhY2VGb3JJRSgpIHtcbiAgICAgICAgaWYgKGNvbnNvbGUubG9nKSB7XG4gICAgICAgICAgICBpZiAoY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBJbiBvbGQgSUUsIG5hdGl2ZSBjb25zb2xlIG1ldGhvZHMgdGhlbXNlbHZlcyBkb24ndCBoYXZlIGFwcGx5KCkuXG4gICAgICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbnNvbGUudHJhY2UpIGNvbnNvbGUudHJhY2UoKTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgYmVzdCBsb2dnaW5nIG1ldGhvZCBwb3NzaWJsZSBmb3IgdGhpcyBlbnZcbiAgICAvLyBXaGVyZXZlciBwb3NzaWJsZSB3ZSB3YW50IHRvIGJpbmQsIG5vdCB3cmFwLCB0byBwcmVzZXJ2ZSBzdGFjayB0cmFjZXNcbiAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgIG1ldGhvZE5hbWUgPSAnbG9nJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgY29uc29sZSA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhY2VGb3JJRTtcbiAgICAgICAgfSBlbHNlIGlmIChjb25zb2xlW21ldGhvZE5hbWVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsIG1ldGhvZE5hbWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnNvbGUubG9nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgcHJpdmF0ZSBmdW5jdGlvbnMgYWx3YXlzIG5lZWQgYHRoaXNgIHRvIGJlIHNldCBwcm9wZXJseVxuXG4gICAgZnVuY3Rpb24gcmVwbGFjZUxvZ2dpbmdNZXRob2RzKGxldmVsLCBsb2dnZXJOYW1lKSB7XG4gICAgICAgIC8qanNoaW50IHZhbGlkdGhpczp0cnVlICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9nTWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIG1ldGhvZE5hbWUgPSBsb2dNZXRob2RzW2ldO1xuICAgICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IChpIDwgbGV2ZWwpID9cbiAgICAgICAgICAgICAgICBub29wIDpcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVmaW5lIGxvZy5sb2cgYXMgYW4gYWxpYXMgZm9yIGxvZy5kZWJ1Z1xuICAgICAgICB0aGlzLmxvZyA9IHRoaXMuZGVidWc7XG4gICAgfVxuXG4gICAgLy8gSW4gb2xkIElFIHZlcnNpb25zLCB0aGUgY29uc29sZSBpc24ndCBwcmVzZW50IHVudGlsIHlvdSBmaXJzdCBvcGVuIGl0LlxuICAgIC8vIFdlIGJ1aWxkIHJlYWxNZXRob2QoKSByZXBsYWNlbWVudHMgaGVyZSB0aGF0IHJlZ2VuZXJhdGUgbG9nZ2luZyBtZXRob2RzXG4gICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lLCBsZXZlbCwgbG9nZ2VyTmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwodGhpcywgbGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBCeSBkZWZhdWx0LCB3ZSB1c2UgY2xvc2VseSBib3VuZCByZWFsIG1ldGhvZHMgd2hlcmV2ZXIgcG9zc2libGUsIGFuZFxuICAgIC8vIG90aGVyd2lzZSB3ZSB3YWl0IGZvciBhIGNvbnNvbGUgdG8gYXBwZWFyLCBhbmQgdGhlbiB0cnkgYWdhaW4uXG4gICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgcmV0dXJuIHJlYWxNZXRob2QobWV0aG9kTmFtZSkgfHxcbiAgICAgICAgICAgICAgIGVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZGVmYXVsdExldmVsLCBmYWN0b3J5KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgY3VycmVudExldmVsO1xuICAgICAgZGVmYXVsdExldmVsID0gZGVmYXVsdExldmVsID09IG51bGwgPyBcIldBUk5cIiA6IGRlZmF1bHRMZXZlbDtcblxuICAgICAgdmFyIHN0b3JhZ2VLZXkgPSBcImxvZ2xldmVsXCI7XG4gICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgIHN0b3JhZ2VLZXkgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XSA9IGxldmVsTmFtZTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPVxuICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KSArIFwiPVwiICsgbGV2ZWxOYW1lICsgXCI7XCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICB2YXIgc3RvcmVkTGV2ZWw7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGNvb2tpZXMgaWYgbG9jYWwgc3RvcmFnZSBnaXZlcyB1cyBub3RoaW5nXG4gICAgICAgICAgaWYgKHR5cGVvZiBzdG9yZWRMZXZlbCA9PT0gdW5kZWZpbmVkVHlwZSkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgdmFyIGNvb2tpZSA9IHdpbmRvdy5kb2N1bWVudC5jb29raWU7XG4gICAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBjb29raWUuaW5kZXhPZihcbiAgICAgICAgICAgICAgICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RvcmFnZUtleSkgKyBcIj1cIik7XG4gICAgICAgICAgICAgICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RvcmVkTGV2ZWwgPSAvXihbXjtdKykvLmV4ZWMoY29va2llLnNsaWNlKGxvY2F0aW9uKSlbMV07XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB0aGUgc3RvcmVkIGxldmVsIGlzIG5vdCB2YWxpZCwgdHJlYXQgaXQgYXMgaWYgbm90aGluZyB3YXMgc3RvcmVkLlxuICAgICAgICAgIGlmIChzZWxmLmxldmVsc1tzdG9yZWRMZXZlbF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICBzdG9yZWRMZXZlbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09IHVuZGVmaW5lZFR5cGUgfHwgIXN0b3JhZ2VLZXkpIHJldHVybjtcblxuICAgICAgICAgIC8vIFVzZSBsb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuXG4gICAgICAgICAgLy8gVXNlIHNlc3Npb24gY29va2llIGFzIGZhbGxiYWNrXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9XG4gICAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgICpcbiAgICAgICAqIFB1YmxpYyBsb2dnZXIgQVBJIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCBmb3IgZGV0YWlsc1xuICAgICAgICpcbiAgICAgICAqL1xuXG4gICAgICBzZWxmLm5hbWUgPSBuYW1lO1xuXG4gICAgICBzZWxmLmxldmVscyA9IHsgXCJUUkFDRVwiOiAwLCBcIkRFQlVHXCI6IDEsIFwiSU5GT1wiOiAyLCBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsIFwiU0lMRU5UXCI6IDV9O1xuXG4gICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuXG4gICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBjdXJyZW50TGV2ZWw7XG4gICAgICB9O1xuXG4gICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGxldmVsID0gc2VsZi5sZXZlbHNbbGV2ZWwudG9VcHBlckNhc2UoKV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgbGV2ZWwgPT09IFwibnVtYmVyXCIgJiYgbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgY3VycmVudExldmVsID0gbGV2ZWw7XG4gICAgICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkgeyAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZShsZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZiwgbGV2ZWwsIG5hbWUpO1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09IHVuZGVmaW5lZFR5cGUgJiYgbGV2ZWwgPCBzZWxmLmxldmVscy5TSUxFTlQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBcIk5vIGNvbnNvbGUgYXZhaWxhYmxlIGZvciBsb2dnaW5nXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBcImxvZy5zZXRMZXZlbCgpIGNhbGxlZCB3aXRoIGludmFsaWQgbGV2ZWw6IFwiICsgbGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc2VsZi5zZXREZWZhdWx0TGV2ZWwgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgICBkZWZhdWx0TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICBpZiAoIWdldFBlcnNpc3RlZExldmVsKCkpIHtcbiAgICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHNlbGYucmVzZXRMZXZlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBzZWxmLnNldExldmVsKGRlZmF1bHRMZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIGNsZWFyUGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgIH07XG5cbiAgICAgIHNlbGYuZW5hYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuVFJBQ0UsIHBlcnNpc3QpO1xuICAgICAgfTtcblxuICAgICAgc2VsZi5kaXNhYmxlQWxsID0gZnVuY3Rpb24ocGVyc2lzdCkge1xuICAgICAgICAgIHNlbGYuc2V0TGV2ZWwoc2VsZi5sZXZlbHMuU0lMRU5ULCBwZXJzaXN0KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCB0aGUgcmlnaHQgbGV2ZWxcbiAgICAgIHZhciBpbml0aWFsTGV2ZWwgPSBnZXRQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgaWYgKGluaXRpYWxMZXZlbCA9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbExldmVsID0gZGVmYXVsdExldmVsO1xuICAgICAgfVxuICAgICAgc2VsZi5zZXRMZXZlbChpbml0aWFsTGV2ZWwsIGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKlxuICAgICAqXG4gICAgICogVG9wLWxldmVsIEFQSVxuICAgICAqXG4gICAgICovXG5cbiAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuICAgIHZhciBfbG9nZ2Vyc0J5TmFtZSA9IHt9O1xuICAgIGRlZmF1bHRMb2dnZXIuZ2V0TG9nZ2VyID0gZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgICAgICAgaWYgKCh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIikgfHwgbmFtZSA9PT0gXCJcIikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBzdXBwbHkgYSBuYW1lIHdoZW4gY3JlYXRpbmcgYSBsb2dnZXIuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihcbiAgICAgICAgICAgIG5hbWUsIGRlZmF1bHRMb2dnZXIuZ2V0TGV2ZWwoKSwgZGVmYXVsdExvZ2dlci5tZXRob2RGYWN0b3J5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyO1xuICAgIH07XG5cbiAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICB2YXIgX2xvZyA9ICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlKSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgZGVmYXVsdExvZ2dlci5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmXG4gICAgICAgICAgICAgICB3aW5kb3cubG9nID09PSBkZWZhdWx0TG9nZ2VyKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyO1xuICAgIH07XG5cbiAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgfTtcblxuICAgIC8vIEVTNiBkZWZhdWx0IGV4cG9ydCwgZm9yIGNvbXBhdGliaWxpdHlcbiAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuXG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG59KSk7XG4iLCJpbXBvcnQgKiBhcyBsb2cgZnJvbSAnbG9nbGV2ZWwnO1xuXG5leHBvcnQgZW51bSBMb2dMZXZlbCB7XG4gIHRyYWNlID0gMCxcbiAgZGVidWcgPSAxLFxuICBpbmZvID0gMixcbiAgd2FybiA9IDMsXG4gIGVycm9yID0gNCxcbiAgc2lsZW50ID0gNSxcbn1cblxudHlwZSBMb2dMZXZlbFN0cmluZyA9IGtleW9mIHR5cGVvZiBMb2dMZXZlbDtcblxudHlwZSBTdHJ1Y3R1cmVkTG9nZ2VyID0ge1xuICB0cmFjZTogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICBkZWJ1ZzogKG1zZzogc3RyaW5nLCBjb250ZXh0Pzogb2JqZWN0KSA9PiB2b2lkO1xuICBpbmZvOiAobXNnOiBzdHJpbmcsIGNvbnRleHQ/OiBvYmplY3QpID0+IHZvaWQ7XG4gIHdhcm46IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgZXJyb3I6IChtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcbiAgc2V0RGVmYXVsdExldmVsOiAobGV2ZWw6IGxvZy5Mb2dMZXZlbERlc2MpID0+IHZvaWQ7XG59O1xuXG5jb25zdCBsaXZla2l0TG9nZ2VyID0gbG9nLmdldExvZ2dlcignbGl2ZWtpdCcpO1xuXG5saXZla2l0TG9nZ2VyLnNldERlZmF1bHRMZXZlbChMb2dMZXZlbC5pbmZvKTtcblxuZXhwb3J0IGRlZmF1bHQgbGl2ZWtpdExvZ2dlciBhcyBTdHJ1Y3R1cmVkTG9nZ2VyO1xuXG5leHBvcnQgZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWw6IExvZ0xldmVsIHwgTG9nTGV2ZWxTdHJpbmcsIGxvZ2dlck5hbWU/OiAnbGl2ZWtpdCcgfCAnbGstZTJlZScpIHtcbiAgaWYgKGxvZ2dlck5hbWUpIHtcbiAgICBsb2cuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcbiAgfVxuICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBPYmplY3QudmFsdWVzKGxvZy5nZXRMb2dnZXJzKCkpKSB7XG4gICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBMb2dFeHRlbnNpb24gPSAobGV2ZWw6IExvZ0xldmVsLCBtc2c6IHN0cmluZywgY29udGV4dD86IG9iamVjdCkgPT4gdm9pZDtcblxuLyoqXG4gKiB1c2UgdGhpcyB0byBob29rIGludG8gdGhlIGxvZ2dpbmcgZnVuY3Rpb24gdG8gYWxsb3cgc2VuZGluZyBpbnRlcm5hbCBsaXZla2l0IGxvZ3MgdG8gdGhpcmQgcGFydHkgc2VydmljZXNcbiAqIGlmIHNldCwgdGhlIGJyb3dzZXIgbG9ncyB3aWxsIGxvc2UgdGhlaXIgc3RhY2t0cmFjZSBpbmZvcm1hdGlvbiAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9waW10ZXJyeS9sb2dsZXZlbCN3cml0aW5nLXBsdWdpbnMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uOiBMb2dFeHRlbnNpb24pIHtcbiAgY29uc3Qgb3JpZ2luYWxGYWN0b3J5ID0gbGl2ZWtpdExvZ2dlci5tZXRob2RGYWN0b3J5O1xuXG4gIGxpdmVraXRMb2dnZXIubWV0aG9kRmFjdG9yeSA9IChtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJhd01ldGhvZCA9IG9yaWdpbmFsRmFjdG9yeShtZXRob2ROYW1lLCBjb25maWdMZXZlbCwgbG9nZ2VyTmFtZSk7XG5cbiAgICBjb25zdCBsb2dMZXZlbCA9IExvZ0xldmVsW21ldGhvZE5hbWUgYXMgTG9nTGV2ZWxTdHJpbmddO1xuICAgIGNvbnN0IG5lZWRMb2cgPSBsb2dMZXZlbCA+PSBjb25maWdMZXZlbCAmJiBsb2dMZXZlbCA8IExvZ0xldmVsLnNpbGVudDtcblxuICAgIHJldHVybiAobXNnLCBjb250ZXh0PzogW21zZzogc3RyaW5nLCBjb250ZXh0OiBvYmplY3RdKSA9PiB7XG4gICAgICBpZiAoY29udGV4dCkgcmF3TWV0aG9kKG1zZywgY29udGV4dCk7XG4gICAgICBlbHNlIHJhd01ldGhvZChtc2cpO1xuICAgICAgaWYgKG5lZWRMb2cpIHtcbiAgICAgICAgZXh0ZW5zaW9uKGxvZ0xldmVsLCBtc2csIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIGxpdmVraXRMb2dnZXIuc2V0TGV2ZWwobGl2ZWtpdExvZ2dlci5nZXRMZXZlbCgpKTsgLy8gQmUgc3VyZSB0byBjYWxsIHNldExldmVsIG1ldGhvZCBpbiBvcmRlciB0byBhcHBseSBwbHVnaW5cbn1cblxuZXhwb3J0IGNvbnN0IHdvcmtlckxvZ2dlciA9IGxvZy5nZXRMb2dnZXIoJ2xrLWUyZWUnKSBhcyBTdHJ1Y3R1cmVkTG9nZ2VyO1xuIiwiaW1wb3J0IHR5cGUgeyBLZXlQcm92aWRlck9wdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IEVOQ1JZUFRJT05fQUxHT1JJVEhNID0gJ0FFUy1HQ00nO1xuXG4vLyBXZSB1c2UgYSByaW5nYnVmZmVyIG9mIGtleXMgc28gd2UgY2FuIGNoYW5nZSB0aGVtIGFuZCBzdGlsbCBkZWNvZGUgcGFja2V0cyB0aGF0IHdlcmVcbi8vIGVuY3J5cHRlZCB3aXRoIGFuIG9sZCBrZXkuIFdlIHVzZSBhIHNpemUgb2YgMTYgd2hpY2ggY29ycmVzcG9uZHMgdG8gdGhlIGZvdXIgYml0c1xuLy8gaW4gdGhlIGZyYW1lIHRyYWlsZXIuXG5leHBvcnQgY29uc3QgS0VZUklOR19TSVpFID0gMTY7XG5cbi8vIEhvdyBtYW55IGNvbnNlY3V0aXZlIGZyYW1lcyBjYW4gZmFpbCBkZWNyeXB0aW5nIGJlZm9yZSBhIHBhcnRpY3VsYXIga2V5IGdldHMgbWFya2VkIGFzIGludmFsaWRcbmV4cG9ydCBjb25zdCBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFID0gMTA7XG5cbi8vIFdlIGNvcHkgdGhlIGZpcnN0IGJ5dGVzIG9mIHRoZSBWUDggcGF5bG9hZCB1bmVuY3J5cHRlZC5cbi8vIEZvciBrZXlmcmFtZXMgdGhpcyBpcyAxMCBieXRlcywgZm9yIG5vbi1rZXlmcmFtZXMgKGRlbHRhKSAzLiBTZWVcbi8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYzODYjc2VjdGlvbi05LjFcbi8vIFRoaXMgYWxsb3dzIHRoZSBicmlkZ2UgdG8gY29udGludWUgZGV0ZWN0aW5nIGtleWZyYW1lcyAob25seSBvbmUgYnl0ZSBuZWVkZWQgaW4gdGhlIEpWQilcbi8vIGFuZCBpcyBhbHNvIGEgYml0IGVhc2llciBmb3IgdGhlIFZQOCBkZWNvZGVyIChpLmUuIGl0IGdlbmVyYXRlcyBmdW5ueSBnYXJiYWdlIHBpY3R1cmVzXG4vLyBpbnN0ZWFkIG9mIGJlaW5nIHVuYWJsZSB0byBkZWNvZGUpLlxuLy8gVGhpcyBpcyBhIGJpdCBmb3Igc2hvdyBhbmQgd2UgbWlnaHQgd2FudCB0byByZWR1Y2UgdG8gMSB1bmNvbmRpdGlvbmFsbHkgaW4gdGhlIGZpbmFsIHZlcnNpb24uXG4vL1xuLy8gRm9yIGF1ZGlvICh3aGVyZSBmcmFtZS50eXBlIGlzIG5vdCBzZXQpIHdlIGRvIG5vdCBlbmNyeXB0IHRoZSBvcHVzIFRPQyBieXRlOlxuLy8gICBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjcxNiNzZWN0aW9uLTMuMVxuZXhwb3J0IGNvbnN0IFVORU5DUllQVEVEX0JZVEVTID0ge1xuICBrZXk6IDEwLFxuICBkZWx0YTogMyxcbiAgYXVkaW86IDEsIC8vIGZyYW1lLnR5cGUgaXMgbm90IHNldCBvbiBhdWRpbywgc28gdGhpcyBpcyBzZXQgbWFudWFsbHlcbiAgZW1wdHk6IDAsXG59IGFzIGNvbnN0O1xuXG4vKiBXZSB1c2UgYSAxMiBieXRlIGJpdCBJVi4gVGhpcyBpcyBzaWduYWxsZWQgaW4gcGxhaW4gdG9nZXRoZXIgd2l0aCB0aGVcbiBwYWNrZXQuIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2VuY3J5cHQjcGFyYW1ldGVycyAqL1xuZXhwb3J0IGNvbnN0IElWX0xFTkdUSCA9IDEyO1xuXG4vLyBmbGFnIHNldCB0byBpbmRpY2F0ZSB0aGF0IGUyZWUgaGFzIGJlZW4gc2V0dXAgZm9yIHNlbmRlci9yZWNlaXZlcjtcbmV4cG9ydCBjb25zdCBFMkVFX0ZMQUcgPSAnbGtfZTJlZSc7XG5cbmV4cG9ydCBjb25zdCBTQUxUID0gJ0xLRnJhbWVFbmNyeXB0aW9uS2V5JztcblxuZXhwb3J0IGNvbnN0IEtFWV9QUk9WSURFUl9ERUZBVUxUUzogS2V5UHJvdmlkZXJPcHRpb25zID0ge1xuICBzaGFyZWRLZXk6IGZhbHNlLFxuICByYXRjaGV0U2FsdDogU0FMVCxcbiAgcmF0Y2hldFdpbmRvd1NpemU6IDgsXG4gIGZhaWx1cmVUb2xlcmFuY2U6IERFQ1JZUFRJT05fRkFJTFVSRV9UT0xFUkFOQ0UsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgTUFYX1NJRl9DT1VOVCA9IDEwMDtcbmV4cG9ydCBjb25zdCBNQVhfU0lGX0RVUkFUSU9OID0gMjAwMDtcbiIsImV4cG9ydCBjbGFzcyBMaXZla2l0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvZGU6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihjb2RlOiBudW1iZXIsIG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlIHx8ICdhbiBlcnJvciBoYXMgb2NjdXJlZCcpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGVudW0gQ29ubmVjdGlvbkVycm9yUmVhc29uIHtcbiAgTm90QWxsb3dlZCxcbiAgU2VydmVyVW5yZWFjaGFibGUsXG4gIEludGVybmFsRXJyb3IsXG4gIENhbmNlbGxlZCxcbn1cblxuZXhwb3J0IGNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIHN0YXR1cz86IG51bWJlcjtcblxuICByZWFzb24/OiBDb25uZWN0aW9uRXJyb3JSZWFzb247XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZywgcmVhc29uPzogQ29ubmVjdGlvbkVycm9yUmVhc29uLCBzdGF0dXM/OiBudW1iZXIpIHtcbiAgICBzdXBlcigxLCBtZXNzYWdlKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigyMSwgbWVzc2FnZSA/PyAnZGV2aWNlIGlzIHVuc3VwcG9ydGVkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFRyYWNrSW52YWxpZEVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDIwLCBtZXNzYWdlID8/ICd0cmFjayBpcyBpbnZhbGlkJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVuc3VwcG9ydGVkU2VydmVyIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZT86IHN0cmluZykge1xuICAgIHN1cGVyKDEwLCBtZXNzYWdlID8/ICd1bnN1cHBvcnRlZCBzZXJ2ZXInKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMiwgbWVzc2FnZSA/PyAndW5leHBlY3RlZCBjb25uZWN0aW9uIHN0YXRlJyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE5lZ290aWF0aW9uRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIoMTMsIG1lc3NhZ2UgPz8gJ3VuYWJsZSB0byBuZWdvdGlhdGUnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcigxMywgbWVzc2FnZSA/PyAndW5hYmxlIHRvIHB1Ymxpc2ggZGF0YScpO1xuICB9XG59XG5cbmV4cG9ydCBlbnVtIE1lZGlhRGV2aWNlRmFpbHVyZSB7XG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcbiAgUGVybWlzc2lvbkRlbmllZCA9ICdQZXJtaXNzaW9uRGVuaWVkJyxcbiAgLy8gZGV2aWNlIGlzIG5vdCBhdmFpbGFibGVcbiAgTm90Rm91bmQgPSAnTm90Rm91bmQnLFxuICAvLyBkZXZpY2UgaXMgaW4gdXNlLiBPbiBXaW5kb3dzLCBvbmx5IGEgc2luZ2xlIHRhYiBtYXkgZ2V0IGFjY2VzcyB0byBhIGRldmljZSBhdCBhIHRpbWUuXG4gIERldmljZUluVXNlID0gJ0RldmljZUluVXNlJyxcbiAgT3RoZXIgPSAnT3RoZXInLFxufVxuXG5leHBvcnQgbmFtZXNwYWNlIE1lZGlhRGV2aWNlRmFpbHVyZSB7XG4gIGV4cG9ydCBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yOiBhbnkpOiBNZWRpYURldmljZUZhaWx1cmUgfCB1bmRlZmluZWQge1xuICAgIGlmIChlcnJvciAmJiAnbmFtZScgaW4gZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90Rm91bmRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ0RldmljZXNOb3RGb3VuZEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLk5vdEZvdW5kO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InIHx8IGVycm9yLm5hbWUgPT09ICdQZXJtaXNzaW9uRGVuaWVkRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuUGVybWlzc2lvbkRlbmllZDtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5uYW1lID09PSAnTm90UmVhZGFibGVFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1RyYWNrU3RhcnRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5EZXZpY2VJblVzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuT3RoZXI7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBMaXZla2l0RXJyb3IgfSBmcm9tICcuLi9yb29tL2Vycm9ycyc7XG5cbmV4cG9ydCBlbnVtIENyeXB0b3JFcnJvclJlYXNvbiB7XG4gIEludmFsaWRLZXkgPSAwLFxuICBNaXNzaW5nS2V5ID0gMSxcbiAgSW50ZXJuYWxFcnJvciA9IDIsXG59XG5cbmV4cG9ydCBjbGFzcyBDcnlwdG9yRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICByZWFzb246IENyeXB0b3JFcnJvclJlYXNvbjtcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nLCByZWFzb246IENyeXB0b3JFcnJvclJlYXNvbiA9IENyeXB0b3JFcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKSB7XG4gICAgc3VwZXIoNDAsIG1lc3NhZ2UpO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICB9XG59XG4iLCJpbXBvcnQgdHlwZSBQYXJ0aWNpcGFudCBmcm9tICcuLi9yb29tL3BhcnRpY2lwYW50L1BhcnRpY2lwYW50JztcbmltcG9ydCB0eXBlIHsgQ3J5cHRvckVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHR5cGUgeyBLZXlJbmZvIH0gZnJvbSAnLi90eXBlcyc7XG5cbmV4cG9ydCBlbnVtIEtleVByb3ZpZGVyRXZlbnQge1xuICBTZXRLZXkgPSAnc2V0S2V5JyxcbiAgUmF0Y2hldFJlcXVlc3QgPSAncmF0Y2hldFJlcXVlc3QnLFxuICBLZXlSYXRjaGV0ZWQgPSAna2V5UmF0Y2hldGVkJyxcbn1cblxuZXhwb3J0IHR5cGUgS2V5UHJvdmlkZXJDYWxsYmFja3MgPSB7XG4gIFtLZXlQcm92aWRlckV2ZW50LlNldEtleV06IChrZXlJbmZvOiBLZXlJbmZvKSA9PiB2b2lkO1xuICBbS2V5UHJvdmlkZXJFdmVudC5SYXRjaGV0UmVxdWVzdF06IChwYXJ0aWNpcGFudElkZW50aXR5Pzogc3RyaW5nLCBrZXlJbmRleD86IG51bWJlcikgPT4gdm9pZDtcbiAgW0tleVByb3ZpZGVyRXZlbnQuS2V5UmF0Y2hldGVkXTogKG1hdGVyaWFsOiBDcnlwdG9LZXksIGtleUluZGV4PzogbnVtYmVyKSA9PiB2b2lkO1xufTtcblxuZXhwb3J0IGVudW0gS2V5SGFuZGxlckV2ZW50IHtcbiAgS2V5UmF0Y2hldGVkID0gJ2tleVJhdGNoZXRlZCcsXG59XG5cbmV4cG9ydCB0eXBlIFBhcnRpY2lwYW50S2V5SGFuZGxlckNhbGxiYWNrcyA9IHtcbiAgW0tleUhhbmRsZXJFdmVudC5LZXlSYXRjaGV0ZWRdOiAoXG4gICAgbWF0ZXJpYWw6IENyeXB0b0tleSxcbiAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcsXG4gICAga2V5SW5kZXg/OiBudW1iZXIsXG4gICkgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBlbnVtIEVuY3J5cHRpb25FdmVudCB7XG4gIFBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQgPSAncGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCcsXG4gIEVuY3J5cHRpb25FcnJvciA9ICdlbmNyeXB0aW9uRXJyb3InLFxufVxuXG5leHBvcnQgdHlwZSBFMkVFTWFuYWdlckNhbGxiYWNrcyA9IHtcbiAgW0VuY3J5cHRpb25FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXTogKFxuICAgIGVuYWJsZWQ6IGJvb2xlYW4sXG4gICAgcGFydGljaXBhbnQ6IFBhcnRpY2lwYW50LFxuICApID0+IHZvaWQ7XG4gIFtFbmNyeXB0aW9uRXZlbnQuRW5jcnlwdGlvbkVycm9yXTogKGVycm9yOiBFcnJvcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCB0eXBlIENyeXB0b3JDYWxsYmFja3MgPSB7XG4gIFtDcnlwdG9yRXZlbnQuRXJyb3JdOiAoZXJyb3I6IENyeXB0b3JFcnJvcikgPT4gdm9pZDtcbn07XG5cbmV4cG9ydCBlbnVtIENyeXB0b3JFdmVudCB7XG4gIEVycm9yID0gJ2NyeXB0b3JFcnJvcicsXG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xubW9kdWxlLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG52YXIgZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG5mdW5jdGlvbiBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRFbWl0dGVyLCAnZGVmYXVsdE1heExpc3RlbmVycycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZGVmYXVsdE1heExpc3RlbmVycztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiZGVmYXVsdE1heExpc3RlbmVyc1wiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBhcmcgKyAnLicpO1xuICAgIH1cbiAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICB9XG59KTtcblxuRXZlbnRFbWl0dGVyLmluaXQgPSBmdW5jdGlvbigpIHtcblxuICBpZiAodGhpcy5fZXZlbnRzID09PSB1bmRlZmluZWQgfHxcbiAgICAgIHRoaXMuX2V2ZW50cyA9PT0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLl9ldmVudHMpIHtcbiAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59O1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICBpZiAodHlwZW9mIG4gIT09ICdudW1iZXInIHx8IG4gPCAwIHx8IE51bWJlcklzTmFOKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcIm5cIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgbiArICcuJyk7XG4gIH1cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgaWYgKHRoYXQuX21heExpc3RlbmVycyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgcmV0dXJuIHRoYXQuX21heExpc3RlbmVycztcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5nZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBnZXRNYXhMaXN0ZW5lcnMoKSB7XG4gIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdCh0eXBlKSB7XG4gIHZhciBhcmdzID0gW107XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgdmFyIGRvRXJyb3IgPSAodHlwZSA9PT0gJ2Vycm9yJyk7XG5cbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKVxuICAgIGRvRXJyb3IgPSAoZG9FcnJvciAmJiBldmVudHMuZXJyb3IgPT09IHVuZGVmaW5lZCk7XG4gIGVsc2UgaWYgKCFkb0Vycm9yKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmIChkb0Vycm9yKSB7XG4gICAgdmFyIGVyO1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDApXG4gICAgICBlciA9IGFyZ3NbMF07XG4gICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgLy8gdXAgaW4gTm9kZSdzIG91dHB1dCBpZiB0aGlzIHJlc3VsdHMgaW4gYW4gdW5oYW5kbGVkIGV4Y2VwdGlvbi5cbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgIH1cbiAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5oYW5kbGVkIGVycm9yLicgKyAoZXIgPyAnICgnICsgZXIubWVzc2FnZSArICcpJyA6ICcnKSk7XG4gICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICB0aHJvdyBlcnI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gIH1cblxuICB2YXIgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoaGFuZGxlciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0QXBwbHkoaGFuZGxlciwgdGhpcywgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIFJlZmxlY3RBcHBseShsaXN0ZW5lcnNbaV0sIHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5mdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICB2YXIgbTtcbiAgdmFyIGV2ZW50cztcbiAgdmFyIGV4aXN0aW5nO1xuXG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXQuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgLy8gUmUtYXNzaWduIGBldmVudHNgIGJlY2F1c2UgYSBuZXdMaXN0ZW5lciBoYW5kbGVyIGNvdWxkIGhhdmUgY2F1c2VkIHRoZVxuICAgICAgLy8gdGhpcy5fZXZlbnRzIHRvIGJlIGFzc2lnbmVkIHRvIGEgbmV3IG9iamVjdFxuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgfVxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdO1xuICB9XG5cbiAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID1cbiAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICBleGlzdGluZy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgIGlmIChtID4gMCAmJiBleGlzdGluZy5sZW5ndGggPiBtICYmICFleGlzdGluZy53YXJuZWQpIHtcbiAgICAgIGV4aXN0aW5nLndhcm5lZCA9IHRydWU7XG4gICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4XG4gICAgICB2YXIgdyA9IG5ldyBFcnJvcignUG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSBsZWFrIGRldGVjdGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmcubGVuZ3RoICsgJyAnICsgU3RyaW5nKHR5cGUpICsgJyBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhZGRlZC4gVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdpbmNyZWFzZSBsaW1pdCcpO1xuICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICB3LmVtaXR0ZXIgPSB0YXJnZXQ7XG4gICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgIFByb2Nlc3NFbWl0V2FybmluZyh3KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gYWRkTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIHRydWUpO1xuICAgIH07XG5cbmZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICB0aGlzLnByZXBlbmRMaXN0ZW5lcih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbi8vIEVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZiBhbmQgb25seSBpZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG5cbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBsaXN0ID0gZXZlbnRzW3R5cGVdO1xuICAgICAgaWYgKGxpc3QgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGxpc3QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcG9zaXRpb24gPSAtMTtcblxuICAgICAgICBmb3IgKGkgPSBsaXN0Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvcmlnaW5hbExpc3RlbmVyID0gbGlzdFtpXS5saXN0ZW5lcjtcbiAgICAgICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uID09PSAwKVxuICAgICAgICAgIGxpc3Quc2hpZnQoKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuXG4gICAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgICAgIGlmIChldmVudHMucmVtb3ZlTGlzdGVuZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhldmVudHMpO1xuICAgICAgICB2YXIga2V5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVycyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgICB9IGVsc2UgaWYgKGxpc3RlbmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIExJRk8gb3JkZXJcbiAgICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbmZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgdmFyIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gIGlmIChldmxpc3RlbmVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/XG4gICAgdW53cmFwTGlzdGVuZXJzKGV2bGlzdGVuZXIpIDogYXJyYXlDbG9uZShldmxpc3RlbmVyLCBldmxpc3RlbmVyLmxlbmd0aCk7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJhd0xpc3RlbmVycyA9IGZ1bmN0aW9uIHJhd0xpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gbGlzdGVuZXJDb3VudDtcbmZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuXG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKGV2bGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xufTtcblxuZnVuY3Rpb24gYXJyYXlDbG9uZShhcnIsIG4pIHtcbiAgdmFyIGNvcHkgPSBuZXcgQXJyYXkobik7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKVxuICAgIGNvcHlbaV0gPSBhcnJbaV07XG4gIHJldHVybiBjb3B5O1xufVxuXG5mdW5jdGlvbiBzcGxpY2VPbmUobGlzdCwgaW5kZXgpIHtcbiAgZm9yICg7IGluZGV4ICsgMSA8IGxpc3QubGVuZ3RoOyBpbmRleCsrKVxuICAgIGxpc3RbaW5kZXhdID0gbGlzdFtpbmRleCArIDFdO1xuICBsaXN0LnBvcCgpO1xufVxuXG5mdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoYXJyLmxlbmd0aCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcmV0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBmdW5jdGlvbiBlcnJvckxpc3RlbmVyKGVycikge1xuICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICByZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNvbHZlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIH07XG5cbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgcmVzb2x2ZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICBpZiAobmFtZSAhPT0gJ2Vycm9yJykge1xuICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGhhbmRsZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIGxpc3RlbmVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgZW1pdHRlci5vbmNlKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZW1pdHRlci5vbihuYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBFdmVudFRhcmdldCBkb2VzIG5vdCBoYXZlIGBlcnJvcmAgZXZlbnQgc2VtYW50aWNzIGxpa2UgTm9kZVxuICAgIC8vIEV2ZW50RW1pdHRlcnMsIHdlIGRvIG5vdCBsaXN0ZW4gZm9yIGBlcnJvcmAgZXZlbnRzIGhlcmUuXG4gICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgIC8vIElFIGRvZXMgbm90IGhhdmUgYnVpbHRpbiBgeyBvbmNlOiB0cnVlIH1gIHN1cHBvcnQgc28gd2VcbiAgICAgIC8vIGhhdmUgdG8gZG8gaXQgbWFudWFsbHkuXG4gICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICBlbWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgd3JhcExpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBUcmFjayB9IGZyb20gJy4vVHJhY2snO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRyYWNrUHVibGlzaERlZmF1bHRzIHtcbiAgLyoqXG4gICAqIGVuY29kaW5nIHBhcmFtZXRlcnMgZm9yIGNhbWVyYSB0cmFja1xuICAgKi9cbiAgdmlkZW9FbmNvZGluZz86IFZpZGVvRW5jb2Rpbmc7XG5cbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIGJhY2t1cENvZGVjPzogeyBjb2RlYzogQmFja3VwVmlkZW9Db2RlYzsgZW5jb2Rpbmc6IFZpZGVvRW5jb2RpbmcgfSB8IGZhbHNlO1xuXG4gIC8qKlxuICAgKiBlbmNvZGluZyBwYXJhbWV0ZXJzIGZvciBzY3JlZW4gc2hhcmUgdHJhY2tcbiAgICovXG4gIHNjcmVlblNoYXJlRW5jb2Rpbmc/OiBWaWRlb0VuY29kaW5nO1xuXG4gIC8qKlxuICAgKiBjb2RlYywgZGVmYXVsdHMgdG8gdnA4OyBmb3Igc3ZjIGNvZGVjcywgYXV0byBlbmFibGUgdnA4XG4gICAqIGFzIGJhY2t1cC4gKFRCRClcbiAgICovXG4gIHZpZGVvQ29kZWM/OiBWaWRlb0NvZGVjO1xuXG4gIC8qKlxuICAgKiBtYXggYXVkaW8gYml0cmF0ZSwgZGVmYXVsdHMgdG8gW1tBdWRpb1ByZXNldHMubXVzaWNdXVxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGF1ZGlvUHJlc2V0YCBpbnN0ZWFkXG4gICAqL1xuICBhdWRpb0JpdHJhdGU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIHdoaWNoIGF1ZGlvIHByZXNldCBzaG91bGQgYmUgdXNlZCBmb3IgcHVibGlzaGluZyAoYXVkaW8pIHRyYWNrc1xuICAgKiBkZWZhdWx0cyB0byBbW0F1ZGlvUHJlc2V0cy5tdXNpY11dXG4gICAqL1xuICBhdWRpb1ByZXNldD86IEF1ZGlvUHJlc2V0O1xuXG4gIC8qKlxuICAgKiBkdHggKERpc2NvbnRpbnVvdXMgVHJhbnNtaXNzaW9uIG9mIGF1ZGlvKSwgZW5hYmxlZCBieSBkZWZhdWx0IGZvciBtb25vIHRyYWNrcy5cbiAgICovXG4gIGR0eD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHJlZCAoUmVkdW5kYW50IEF1ZGlvIERhdGEpLCBlbmFibGVkIGJ5IGRlZmF1bHQgZm9yIG1vbm8gdHJhY2tzLlxuICAgKi9cbiAgcmVkPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogcHVibGlzaCB0cmFjayBpbiBzdGVyZW8gbW9kZSAob3Igc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUpLiBkZWZhdWx0cyBkZXRlcm1pbmVkIGJ5IGNhcHR1cmUgY2hhbm5lbCBjb3VudC5cbiAgICovXG4gIGZvcmNlU3RlcmVvPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogdXNlIHNpbXVsY2FzdCwgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogV2hlbiB1c2luZyBzaW11bGNhc3QsIExpdmVLaXQgd2lsbCBwdWJsaXNoIHVwIHRvIHRocmVlIHZlcnNpb25zIG9mIHRoZSBzdHJlYW1cbiAgICogYXQgdmFyaW91cyByZXNvbHV0aW9ucy5cbiAgICovXG4gIHNpbXVsY2FzdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHNjYWxhYmlsaXR5IG1vZGUgZm9yIHN2YyBjb2RlY3MsIGRlZmF1bHRzIHRvICdMM1QzJy5cbiAgICogZm9yIHN2YyBjb2RlY3MsIHNpbXVsY2FzdCBpcyBkaXNhYmxlZC5cbiAgICovXG4gIHNjYWxhYmlsaXR5TW9kZT86IFNjYWxhYmlsaXR5TW9kZTtcblxuICAvKipcbiAgICogVXAgdG8gdHdvIGFkZGl0aW9uYWwgc2ltdWxjYXN0IGxheWVycyB0byBwdWJsaXNoIGluIGFkZGl0aW9uIHRvIHRoZSBvcmlnaW5hbFxuICAgKiBUcmFjay5cbiAgICogV2hlbiBsZWZ0IGJsYW5rLCBpdCBkZWZhdWx0cyB0byBoMTgwLCBoMzYwLlxuICAgKiBJZiBhIFNWQyBjb2RlYyBpcyB1c2VkIChWUDkgb3IgQVYxKSwgdGhpcyBmaWVsZCBoYXMgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBUbyBwdWJsaXNoIHRocmVlIHRvdGFsIGxheWVycywgeW91IHdvdWxkIHNwZWNpZnk6XG4gICAqIHtcbiAgICogICB2aWRlb0VuY29kaW5nOiB7Li4ufSwgLy8gZW5jb2Rpbmcgb2YgdGhlIHByaW1hcnkgbGF5ZXJcbiAgICogICB2aWRlb1NpbXVsY2FzdExheWVyczogW1xuICAgKiAgICAgVmlkZW9QcmVzZXRzLmg1NDAsXG4gICAqICAgICBWaWRlb1ByZXNldHMuaDIxNixcbiAgICogICBdLFxuICAgKiB9XG4gICAqL1xuICB2aWRlb1NpbXVsY2FzdExheWVycz86IEFycmF5PFZpZGVvUHJlc2V0PjtcblxuICAvKipcbiAgICogY3VzdG9tIHZpZGVvIHNpbXVsY2FzdCBsYXllcnMgZm9yIHNjcmVlbiB0cmFja3NcbiAgICogTm90ZTogdGhlIGxheWVycyBuZWVkIHRvIGJlIG9yZGVyZWQgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCBxdWFsaXR5XG4gICAqL1xuICBzY3JlZW5TaGFyZVNpbXVsY2FzdExheWVycz86IEFycmF5PFZpZGVvUHJlc2V0PjtcblxuICAvKipcbiAgICogRm9yIGxvY2FsIHRyYWNrcywgc3RvcCB0aGUgdW5kZXJseWluZyBNZWRpYVN0cmVhbVRyYWNrIHdoZW4gdGhlIHRyYWNrIGlzIG11dGVkIChvciBwYXVzZWQpXG4gICAqIG9uIHNvbWUgcGxhdGZvcm1zLCB0aGlzIG9wdGlvbiBpcyBuZWNlc3NhcnkgdG8gZGlzYWJsZSB0aGUgbWljcm9waG9uZSByZWNvcmRpbmcgaW5kaWNhdG9yLlxuICAgKiBOb3RlOiB3aGVuIHRoaXMgaXMgZW5hYmxlZCwgYW5kIEJUIGRldmljZXMgYXJlIGNvbm5lY3RlZCwgdGhleSB3aWxsIHRyYW5zaXRpb24gYmV0d2VlblxuICAgKiBwcm9maWxlcyAoZS5nLiBIRlAgdG8gQTJEUCkgYW5kIHRoZXJlIHdpbGwgYmUgYW4gYXVkaWJsZSBkaWZmZXJlbmNlIGluIHBsYXliYWNrLlxuICAgKlxuICAgKiBkZWZhdWx0cyB0byBmYWxzZVxuICAgKi9cbiAgc3RvcE1pY1RyYWNrT25NdXRlPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBPcHRpb25zIHdoZW4gcHVibGlzaGluZyB0cmFja3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFja1B1Ymxpc2hPcHRpb25zIGV4dGVuZHMgVHJhY2tQdWJsaXNoRGVmYXVsdHMge1xuICAvKipcbiAgICogc2V0IGEgdHJhY2sgbmFtZVxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogU291cmNlIG9mIHRyYWNrLCBjYW1lcmEsIG1pY3JvcGhvbmUsIG9yIHNjcmVlblxuICAgKi9cbiAgc291cmNlPzogVHJhY2suU291cmNlO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENyZWF0ZUxvY2FsVHJhY2tzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBhdWRpbyB0cmFjayBvcHRpb25zLCB0cnVlIHRvIGNyZWF0ZSB3aXRoIGRlZmF1bHRzLiBmYWxzZSBpZiBhdWRpbyBzaG91bGRuJ3QgYmUgY3JlYXRlZFxuICAgKiBkZWZhdWx0IHRydWVcbiAgICovXG4gIGF1ZGlvPzogYm9vbGVhbiB8IEF1ZGlvQ2FwdHVyZU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIHZpZGVvIHRyYWNrIG9wdGlvbnMsIHRydWUgdG8gY3JlYXRlIHdpdGggZGVmYXVsdHMuIGZhbHNlIGlmIHZpZGVvIHNob3VsZG4ndCBiZSBjcmVhdGVkXG4gICAqIGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgdmlkZW8/OiBib29sZWFuIHwgVmlkZW9DYXB0dXJlT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb0NhcHR1cmVPcHRpb25zIHtcbiAgLyoqXG4gICAqIEEgQ29uc3RyYWluRE9NU3RyaW5nIG9iamVjdCBzcGVjaWZ5aW5nIGEgZGV2aWNlIElEIG9yIGFuIGFycmF5IG9mIGRldmljZVxuICAgKiBJRHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZGV2aWNlSWQ/OiBDb25zdHJhaW5ET01TdHJpbmc7XG5cbiAgLyoqXG4gICAqIGEgZmFjaW5nIG9yIGFuIGFycmF5IG9mIGZhY2luZ3Mgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZmFjaW5nTW9kZT86ICd1c2VyJyB8ICdlbnZpcm9ubWVudCcgfCAnbGVmdCcgfCAncmlnaHQnO1xuXG4gIHJlc29sdXRpb24/OiBWaWRlb1Jlc29sdXRpb247XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NyZWVuU2hhcmVDYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiB0cnVlIHRvIGNhcHR1cmUgYXVkaW8gc2hhcmVkLiBicm93c2VyIHN1cHBvcnQgZm9yIGF1ZGlvIGNhcHR1cmluZyBpblxuICAgKiBzY3JlZW5zaGFyZSBpcyBsaW1pdGVkOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFEZXZpY2VzL2dldERpc3BsYXlNZWRpYSNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICovXG4gIGF1ZGlvPzogYm9vbGVhbiB8IEF1ZGlvQ2FwdHVyZU9wdGlvbnM7XG5cbiAgLyoqXG4gICAqIG9ubHkgYWxsb3dzIGZvciAndHJ1ZScgYW5kIGNocm9tZSBhbGxvd3MgZm9yIGFkZGl0aW9uYWwgb3B0aW9ucyB0byBiZSBwYXNzZWQgaW5cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kb2NzL3dlYi1wbGF0Zm9ybS9zY3JlZW4tc2hhcmluZy1jb250cm9scy8jZGlzcGxheVN1cmZhY2VcbiAgICovXG4gIHZpZGVvPzogdHJ1ZSB8IHsgZGlzcGxheVN1cmZhY2U/OiAnd2luZG93JyB8ICdicm93c2VyJyB8ICdtb25pdG9yJyB9O1xuXG4gIC8qKiBjYXB0dXJlIHJlc29sdXRpb24sIGRlZmF1bHRzIHRvIGZ1bGwgSEQgKi9cbiAgcmVzb2x1dGlvbj86IFZpZGVvUmVzb2x1dGlvbjtcblxuICAvKiogYSBDYXB0dXJlQ29udHJvbGxlciBvYmplY3QgaW5zdGFuY2UgY29udGFpbmluZyBtZXRob2RzIHRoYXQgY2FuIGJlIHVzZWQgdG8gZnVydGhlciBtYW5pcHVsYXRlIHRoZSBjYXB0dXJlIHNlc3Npb24gaWYgaW5jbHVkZWQuICovXG4gIGNvbnRyb2xsZXI/OiB1bmtub3duOyAvLyBUT0RPIHJlcGxhY2UgdHlwZSB3aXRoIENhcHR1cmVDb250cm9sbGVyIG9uY2UgaXQgbGFuZHMgaW4gVHlwZVNjcmlwdFxuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgYWxsb3cgdGhlIHVzZXIgdG8gc2VsZWN0IHRoZSBjdXJyZW50IHRhYiBmb3IgY2FwdHVyZSAqL1xuICBzZWxmQnJvd3NlclN1cmZhY2U/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqIHNwZWNpZmllcyB3aGV0aGVyIHRoZSBicm93c2VyIHNob3VsZCBkaXNwbGF5IGEgY29udHJvbCB0byBhbGxvdyB0aGUgdXNlciB0byBkeW5hbWljYWxseSBzd2l0Y2ggdGhlIHNoYXJlZCB0YWIgZHVyaW5nIHNjcmVlbi1zaGFyaW5nLiAqL1xuICBzdXJmYWNlU3dpdGNoaW5nPzogJ2luY2x1ZGUnIHwgJ2V4Y2x1ZGUnO1xuXG4gIC8qKiBzcGVjaWZpZXMgd2hldGhlciB0aGUgYnJvd3NlciBzaG91bGQgaW5jbHVkZSB0aGUgc3lzdGVtIGF1ZGlvIGFtb25nIHRoZSBwb3NzaWJsZSBhdWRpbyBzb3VyY2VzIG9mZmVyZWQgdG8gdGhlIHVzZXIgKi9cbiAgc3lzdGVtQXVkaW8/OiAnaW5jbHVkZScgfCAnZXhjbHVkZSc7XG5cbiAgLyoqXG4gICAqIEV4cGVyaW1lbnRhbCBvcHRpb24gdG8gY29udHJvbCB3aGV0aGVyIHRoZSBhdWRpbyBwbGF5aW5nIGluIGEgdGFiIHdpbGwgY29udGludWUgdG8gYmUgcGxheWVkIG91dCBvZiBhIHVzZXInc1xuICAgKiBsb2NhbCBzcGVha2VycyB3aGVuIHRoZSB0YWIgaXMgY2FwdHVyZWQuXG4gICAqL1xuICBzdXBwcmVzc0xvY2FsQXVkaW9QbGF5YmFjaz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQXVkaW9DYXB0dXJlT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBzcGVjaWZpZXMgd2hldGhlciBhdXRvbWF0aWMgZ2FpbiBjb250cm9sIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGF1dG9HYWluQ29udHJvbD86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHRoZSBjaGFubmVsIGNvdW50IG9yIHJhbmdlIG9mIGNoYW5uZWwgY291bnRzIHdoaWNoIGFyZSBhY2NlcHRhYmxlIGFuZC9vciByZXF1aXJlZFxuICAgKi9cbiAgY2hhbm5lbENvdW50PzogQ29uc3RyYWluVUxvbmc7XG5cbiAgLyoqXG4gICAqIEEgQ29uc3RyYWluRE9NU3RyaW5nIG9iamVjdCBzcGVjaWZ5aW5nIGEgZGV2aWNlIElEIG9yIGFuIGFycmF5IG9mIGRldmljZVxuICAgKiBJRHMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgZGV2aWNlSWQ/OiBDb25zdHJhaW5ET01TdHJpbmc7XG5cbiAgLyoqXG4gICAqIHdoZXRoZXIgb3Igbm90IGVjaG8gY2FuY2VsbGF0aW9uIGlzIHByZWZlcnJlZCBhbmQvb3IgcmVxdWlyZWRcbiAgICovXG4gIGVjaG9DYW5jZWxsYXRpb24/OiBDb25zdHJhaW5Cb29sZWFuO1xuXG4gIC8qKlxuICAgKiB0aGUgbGF0ZW5jeSBvciByYW5nZSBvZiBsYXRlbmNpZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgbGF0ZW5jeT86IENvbnN0cmFpbkRvdWJsZTtcblxuICAvKipcbiAgICogd2hldGhlciBub2lzZSBzdXBwcmVzc2lvbiBpcyBwcmVmZXJyZWQgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgbm9pc2VTdXBwcmVzc2lvbj86IENvbnN0cmFpbkJvb2xlYW47XG5cbiAgLyoqXG4gICAqIHRoZSBzYW1wbGUgcmF0ZSBvciByYW5nZSBvZiBzYW1wbGUgcmF0ZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgc2FtcGxlUmF0ZT86IENvbnN0cmFpblVMb25nO1xuXG4gIC8qKlxuICAgKiBzYW1wbGUgc2l6ZSBvciByYW5nZSBvZiBzYW1wbGUgc2l6ZXMgd2hpY2ggYXJlIGFjY2VwdGFibGUgYW5kL29yIHJlcXVpcmVkLlxuICAgKi9cbiAgc2FtcGxlU2l6ZT86IENvbnN0cmFpblVMb25nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEF1ZGlvT3V0cHV0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBkZXZpY2VJZCB0byBvdXRwdXQgYXVkaW9cbiAgICpcbiAgICogT25seSBzdXBwb3J0ZWQgb24gYnJvd3NlcnMgd2hlcmUgYHNldFNpbmtJZGAgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBkZXZpY2VJZD86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb1Jlc29sdXRpb24ge1xuICB3aWR0aDogbnVtYmVyO1xuICBoZWlnaHQ6IG51bWJlcjtcbiAgZnJhbWVSYXRlPzogbnVtYmVyO1xuICBhc3BlY3RSYXRpbz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWaWRlb0VuY29kaW5nIHtcbiAgbWF4Qml0cmF0ZTogbnVtYmVyO1xuICBtYXhGcmFtZXJhdGU/OiBudW1iZXI7XG4gIHByaW9yaXR5PzogUlRDUHJpb3JpdHlUeXBlO1xufVxuXG5leHBvcnQgY2xhc3MgVmlkZW9QcmVzZXQge1xuICBlbmNvZGluZzogVmlkZW9FbmNvZGluZztcblxuICB3aWR0aDogbnVtYmVyO1xuXG4gIGhlaWdodDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHdpZHRoOiBudW1iZXIsXG4gICAgaGVpZ2h0OiBudW1iZXIsXG4gICAgbWF4Qml0cmF0ZTogbnVtYmVyLFxuICAgIG1heEZyYW1lcmF0ZT86IG51bWJlcixcbiAgICBwcmlvcml0eT86IFJUQ1ByaW9yaXR5VHlwZSxcbiAgKSB7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIHRoaXMuZW5jb2RpbmcgPSB7XG4gICAgICBtYXhCaXRyYXRlLFxuICAgICAgbWF4RnJhbWVyYXRlLFxuICAgICAgcHJpb3JpdHksXG4gICAgfTtcbiAgfVxuXG4gIGdldCByZXNvbHV0aW9uKCk6IFZpZGVvUmVzb2x1dGlvbiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIGZyYW1lUmF0ZTogdGhpcy5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy53aWR0aCAvIHRoaXMuaGVpZ2h0LFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBBdWRpb1ByZXNldCB7XG4gIG1heEJpdHJhdGU6IG51bWJlcjtcbiAgcHJpb3JpdHk/OiBSVENQcmlvcml0eVR5cGU7XG59XG5cbmNvbnN0IGJhY2t1cENvZGVjcyA9IFsndnA4JywgJ2gyNjQnXSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IHZpZGVvQ29kZWNzID0gWyd2cDgnLCAnaDI2NCcsICd2cDknLCAnYXYxJ10gYXMgY29uc3Q7XG5cbmV4cG9ydCB0eXBlIFZpZGVvQ29kZWMgPSAodHlwZW9mIHZpZGVvQ29kZWNzKVtudW1iZXJdO1xuXG5leHBvcnQgdHlwZSBCYWNrdXBWaWRlb0NvZGVjID0gKHR5cGVvZiBiYWNrdXBDb2RlY3MpW251bWJlcl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0JhY2t1cENvZGVjKGNvZGVjOiBzdHJpbmcpOiBjb2RlYyBpcyBCYWNrdXBWaWRlb0NvZGVjIHtcbiAgcmV0dXJuICEhYmFja3VwQ29kZWNzLmZpbmQoKGJhY2t1cCkgPT4gYmFja3VwID09PSBjb2RlYyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NvZGVjRXF1YWwoYzE6IHN0cmluZyB8IHVuZGVmaW5lZCwgYzI6IHN0cmluZyB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKFxuICAgIGMxPy50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL2F1ZGlvXFwvfHZpZGVvXFwvL3ksICcnKSA9PT1cbiAgICBjMj8udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9hdWRpb1xcL3x2aWRlb1xcLy95LCAnJylcbiAgKTtcbn1cblxuLyoqXG4gKiBzY2FsYWJpbGl0eSBtb2RlcyBmb3Igc3ZjLCBvbmx5IHN1cHByb3QgbDN0MyBub3cuXG4gKi9cbmV4cG9ydCB0eXBlIFNjYWxhYmlsaXR5TW9kZSA9ICdMM1QzJyB8ICdMM1QzX0tFWSc7XG5cbmV4cG9ydCBuYW1lc3BhY2UgQXVkaW9QcmVzZXRzIHtcbiAgZXhwb3J0IGNvbnN0IHRlbGVwaG9uZTogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMTJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3Qgc3BlZWNoOiBBdWRpb1ByZXNldCA9IHtcbiAgICBtYXhCaXRyYXRlOiAyMF8wMDAsXG4gIH07XG4gIGV4cG9ydCBjb25zdCBtdXNpYzogQXVkaW9QcmVzZXQgPSB7XG4gICAgbWF4Qml0cmF0ZTogMzJfMDAwLFxuICB9O1xuICBleHBvcnQgY29uc3QgbXVzaWNTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDQ4XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHk6IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDY0XzAwMCxcbiAgfTtcbiAgZXhwb3J0IGNvbnN0IG11c2ljSGlnaFF1YWxpdHlTdGVyZW86IEF1ZGlvUHJlc2V0ID0ge1xuICAgIG1heEJpdHJhdGU6IDk2XzAwMCxcbiAgfTtcbn1cblxuLyoqXG4gKiBTYW5lIHByZXNldHMgZm9yIHZpZGVvIHJlc29sdXRpb24vZW5jb2RpbmdcbiAqL1xuZXhwb3J0IGNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTBfMDAwLCAyMCksXG4gIGgxODA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDE4MCwgMTYwXzAwMCwgMjApLFxuICBoMjE2OiBuZXcgVmlkZW9QcmVzZXQoMzg0LCAyMTYsIDE4MF8wMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTBfMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg5NjAsIDU0MCwgODAwXzAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxXzcwMF8wMDAsIDMwKSxcbiAgaDEwODA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAzXzAwMF8wMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1XzAwMF8wMDAsIDMwKSxcbiAgaDIxNjA6IG5ldyBWaWRlb1ByZXNldCgzODQwLCAyMTYwLCA4XzAwMF8wMDAsIDMwKSxcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogRm91ciBieSB0aHJlZSBwcmVzZXRzXG4gKi9cbmV4cG9ydCBjb25zdCBWaWRlb1ByZXNldHM0MyA9IHtcbiAgaDEyMDogbmV3IFZpZGVvUHJlc2V0KDE2MCwgMTIwLCA3MF8wMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjVfMDAwLCAyMCksXG4gIGgyNDA6IG5ldyBWaWRlb1ByZXNldCgzMjAsIDI0MCwgMTQwXzAwMCwgMjApLFxuICBoMzYwOiBuZXcgVmlkZW9QcmVzZXQoNDgwLCAzNjAsIDMzMF8wMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDBfMDAwLCAyMCksXG4gIGg1NDA6IG5ldyBWaWRlb1ByZXNldCg3MjAsIDU0MCwgNjAwXzAwMCwgMjUpLFxuICBoNzIwOiBuZXcgVmlkZW9QcmVzZXQoOTYwLCA3MjAsIDFfMzAwXzAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE0NDAsIDEwODAsIDJfMzAwXzAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDNfODAwXzAwMCwgMzApLFxufSBhcyBjb25zdDtcblxuZXhwb3J0IGNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwXzAwMCwgMywgJ21lZGl1bScpLFxuICBoNzIwZnBzNTogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgNDAwXzAwMCwgNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDFfNTAwXzAwMCwgMTUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAyXzAwMF8wMDAsIDMwLCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAyXzUwMF8wMDAsIDE1LCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCA0XzAwMF8wMDAsIDMwLCAnbWVkaXVtJyksXG59IGFzIGNvbnN0O1xuIiwiaW1wb3J0IHsgdmlkZW9Db2RlY3MgfSBmcm9tICcuLi9yb29tL3RyYWNrL29wdGlvbnMnO1xuaW1wb3J0IHR5cGUgeyBWaWRlb0NvZGVjIH0gZnJvbSAnLi4vcm9vbS90cmFjay9vcHRpb25zJztcbmltcG9ydCB7IEVOQ1JZUFRJT05fQUxHT1JJVEhNIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gaXNFMkVFU3VwcG9ydGVkKCkge1xuICByZXR1cm4gaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkKCkgfHwgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkge1xuICAvLyBAdHMtaWdub3JlXG4gIHJldHVybiB0eXBlb2Ygd2luZG93LlJUQ1J0cFNjcmlwdFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHdpbmRvdy5SVENSdHBTZW5kZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVmlkZW9GcmFtZShcbiAgZnJhbWU6IFJUQ0VuY29kZWRBdWRpb0ZyYW1lIHwgUlRDRW5jb2RlZFZpZGVvRnJhbWUsXG4pOiBmcmFtZSBpcyBSVENFbmNvZGVkVmlkZW9GcmFtZSB7XG4gIHJldHVybiAndHlwZScgaW4gZnJhbWU7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbXBvcnRLZXkoXG4gIGtleUJ5dGVzOiBVaW50OEFycmF5IHwgQXJyYXlCdWZmZXIsXG4gIGFsZ29yaXRobTogc3RyaW5nIHwgeyBuYW1lOiBzdHJpbmcgfSA9IHsgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0gfSxcbiAgdXNhZ2U6ICdkZXJpdmUnIHwgJ2VuY3J5cHQnID0gJ2VuY3J5cHQnLFxuKSB7XG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vaW1wb3J0S2V5XG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAncmF3JyxcbiAgICBrZXlCeXRlcyxcbiAgICBhbGdvcml0aG0sXG4gICAgZmFsc2UsXG4gICAgdXNhZ2UgPT09ICdkZXJpdmUnID8gWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddIDogWydlbmNyeXB0JywgJ2RlY3J5cHQnXSxcbiAgKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbVN0cmluZyhwYXNzd29yZDogc3RyaW5nKSB7XG4gIGxldCBlbmMgPSBuZXcgVGV4dEVuY29kZXIoKTtcblxuICBjb25zdCBrZXlNYXRlcmlhbCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KFxuICAgICdyYXcnLFxuICAgIGVuYy5lbmNvZGUocGFzc3dvcmQpLFxuICAgIHtcbiAgICAgIG5hbWU6ICdQQktERjInLFxuICAgIH0sXG4gICAgZmFsc2UsXG4gICAgWydkZXJpdmVCaXRzJywgJ2Rlcml2ZUtleSddLFxuICApO1xuXG4gIHJldHVybiBrZXlNYXRlcmlhbDtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihjcnlwdG9CdWZmZXI6IEFycmF5QnVmZmVyKSB7XG4gIGNvbnN0IGtleU1hdGVyaWFsID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5pbXBvcnRLZXkoJ3JhdycsIGNyeXB0b0J1ZmZlciwgJ0hLREYnLCBmYWxzZSwgW1xuICAgICdkZXJpdmVCaXRzJyxcbiAgICAnZGVyaXZlS2V5JyxcbiAgXSk7XG5cbiAgcmV0dXJuIGtleU1hdGVyaWFsO1xufVxuXG5mdW5jdGlvbiBnZXRBbGdvT3B0aW9ucyhhbGdvcml0aG1OYW1lOiBzdHJpbmcsIHNhbHQ6IHN0cmluZykge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBlbmNvZGVkU2FsdCA9IHRleHRFbmNvZGVyLmVuY29kZShzYWx0KTtcbiAgc3dpdGNoIChhbGdvcml0aG1OYW1lKSB7XG4gICAgY2FzZSAnSEtERic6XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnSEtERicsXG4gICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICBoYXNoOiAnU0hBLTI1NicsXG4gICAgICAgIGluZm86IG5ldyBBcnJheUJ1ZmZlcigxMjgpLFxuICAgICAgfTtcbiAgICBjYXNlICdQQktERjInOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnUEJLREYyJyxcbiAgICAgICAgc2FsdDogZW5jb2RlZFNhbHQsXG4gICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgaXRlcmF0aW9uczogMTAwMDAwLFxuICAgICAgfTtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgYWxnb3JpdGhtICR7YWxnb3JpdGhtTmFtZX0gaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXJpdmVzIGEgc2V0IG9mIGtleXMgZnJvbSB0aGUgbWFzdGVyIGtleS5cbiAqIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4zLjFcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlcml2ZUtleXMobWF0ZXJpYWw6IENyeXB0b0tleSwgc2FsdDogc3RyaW5nKSB7XG4gIGNvbnN0IGFsZ29yaXRobU9wdGlvbnMgPSBnZXRBbGdvT3B0aW9ucyhtYXRlcmlhbC5hbGdvcml0aG0ubmFtZSwgc2FsdCk7XG5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9kZXJpdmVLZXkjSEtERlxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSGtkZlBhcmFtc1xuICBjb25zdCBlbmNyeXB0aW9uS2V5ID0gYXdhaXQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoXG4gICAgYWxnb3JpdGhtT3B0aW9ucyxcbiAgICBtYXRlcmlhbCxcbiAgICB7XG4gICAgICBuYW1lOiBFTkNSWVBUSU9OX0FMR09SSVRITSxcbiAgICAgIGxlbmd0aDogMTI4LFxuICAgIH0sXG4gICAgZmFsc2UsXG4gICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSxcbiAgKTtcblxuICByZXR1cm4geyBtYXRlcmlhbCwgZW5jcnlwdGlvbktleSB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRTJFRUtleSgpOiBVaW50OEFycmF5IHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyhtaW1lVHlwZTogc3RyaW5nKSB7XG4gIGNvbnN0IGNvZGVjID0gbWltZVR5cGUuc3BsaXQoJy8nKVsxXS50b0xvd2VyQ2FzZSgpIGFzIFZpZGVvQ29kZWM7XG4gIGlmICghdmlkZW9Db2RlY3MuaW5jbHVkZXMoY29kZWMpKSB7XG4gICAgdGhyb3cgRXJyb3IoYFZpZGVvIGNvZGVjIG5vdCBzdXBwb3J0ZWQ6ICR7Y29kZWN9YCk7XG4gIH1cbiAgcmV0dXJuIGNvZGVjO1xufVxuXG4vKipcbiAqIFJhdGNoZXRzIGEga2V5LiBTZWVcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuNS4xXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByYXRjaGV0KG1hdGVyaWFsOiBDcnlwdG9LZXksIHNhbHQ6IHN0cmluZyk6IFByb21pc2U8QXJyYXlCdWZmZXI+IHtcbiAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcblxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUJpdHNcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyhhbGdvcml0aG1PcHRpb25zLCBtYXRlcmlhbCwgMjU2KTtcbn1cbiIsImltcG9ydCB7IE1BWF9TSUZfQ09VTlQsIE1BWF9TSUZfRFVSQVRJT04gfSBmcm9tICcuLi9jb25zdGFudHMnO1xuXG5leHBvcnQgY2xhc3MgU2lmR3VhcmQge1xuICBwcml2YXRlIGNvbnNlY3V0aXZlU2lmQ291bnQgPSAwO1xuXG4gIHByaXZhdGUgc2lmU2VxdWVuY2VTdGFydGVkQXQ6IG51bWJlciB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGxhc3RTaWZSZWNlaXZlZEF0OiBudW1iZXIgPSAwO1xuXG4gIHByaXZhdGUgdXNlckZyYW1lc1NpbmNlU2lmOiBudW1iZXIgPSAwO1xuXG4gIHJlY29yZFNpZigpIHtcbiAgICB0aGlzLmNvbnNlY3V0aXZlU2lmQ291bnQgKz0gMTtcbiAgICB0aGlzLnNpZlNlcXVlbmNlU3RhcnRlZEF0ID8/PSBEYXRlLm5vdygpO1xuICAgIHRoaXMubGFzdFNpZlJlY2VpdmVkQXQgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgcmVjb3JkVXNlckZyYW1lKCkge1xuICAgIGlmICh0aGlzLnNpZlNlcXVlbmNlU3RhcnRlZEF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51c2VyRnJhbWVzU2luY2VTaWYgKz0gMTtcbiAgICB9XG4gICAgaWYgKFxuICAgICAgLy8gcmVzZXQgaWYgd2UgcmVjZWl2ZWQgbW9yZSB1c2VyIGZyYW1lcyB0aGFuIFNJRnNcbiAgICAgIHRoaXMudXNlckZyYW1lc1NpbmNlU2lmID4gdGhpcy5jb25zZWN1dGl2ZVNpZkNvdW50IHx8XG4gICAgICAvLyBhbHNvIHJlc2V0IGlmIHdlIGdvdCBhIG5ldyB1c2VyIGZyYW1lIGFuZCB0aGUgbGF0ZXN0IFNJRiBmcmFtZSBoYXNuJ3QgYmVlbiB1cGRhdGVkIGluIGEgd2hpbGVcbiAgICAgIERhdGUubm93KCkgLSB0aGlzLmxhc3RTaWZSZWNlaXZlZEF0ID4gTUFYX1NJRl9EVVJBVElPTlxuICAgICkge1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH1cbiAgfVxuXG4gIGlzU2lmQWxsb3dlZCgpIHtcbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5jb25zZWN1dGl2ZVNpZkNvdW50IDwgTUFYX1NJRl9DT1VOVCAmJlxuICAgICAgKHRoaXMuc2lmU2VxdWVuY2VTdGFydGVkQXQgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICBEYXRlLm5vdygpIC0gdGhpcy5zaWZTZXF1ZW5jZVN0YXJ0ZWRBdCA8IE1BWF9TSUZfRFVSQVRJT04pXG4gICAgKTtcbiAgfVxuXG4gIHJlc2V0KCkge1xuICAgIHRoaXMudXNlckZyYW1lc1NpbmNlU2lmID0gMDtcbiAgICB0aGlzLmNvbnNlY3V0aXZlU2lmQ291bnQgPSAwO1xuICAgIHRoaXMuc2lmU2VxdWVuY2VTdGFydGVkQXQgPSB1bmRlZmluZWQ7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuLy8gVE9ETyBjb2RlIGluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGMvc2FtcGxlcy9ibG9iL2doLXBhZ2VzL3NyYy9jb250ZW50L2luc2VydGFibGUtc3RyZWFtcy9lbmR0b2VuZC1lbmNyeXB0aW9uL2pzL3dvcmtlci5qc1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcbmltcG9ydCB0eXBlIFR5cGVkRXZlbnRFbWl0dGVyIGZyb20gJ3R5cGVkLWVtaXR0ZXInO1xuaW1wb3J0IHsgd29ya2VyTG9nZ2VyIH0gZnJvbSAnLi4vLi4vbG9nZ2VyJztcbmltcG9ydCB0eXBlIHsgVmlkZW9Db2RlYyB9IGZyb20gJy4uLy4uL3Jvb20vdHJhY2svb3B0aW9ucyc7XG5pbXBvcnQgeyBFTkNSWVBUSU9OX0FMR09SSVRITSwgSVZfTEVOR1RILCBVTkVOQ1JZUFRFRF9CWVRFUyB9IGZyb20gJy4uL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBDcnlwdG9yRXJyb3IsIENyeXB0b3JFcnJvclJlYXNvbiB9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBDcnlwdG9yQ2FsbGJhY2tzLCBDcnlwdG9yRXZlbnQgfSBmcm9tICcuLi9ldmVudHMnO1xuaW1wb3J0IHR5cGUgeyBEZWNvZGVSYXRjaGV0T3B0aW9ucywgS2V5UHJvdmlkZXJPcHRpb25zLCBLZXlTZXQgfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBkZXJpdmVLZXlzLCBpc1ZpZGVvRnJhbWUgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgdHlwZSB7IFBhcnRpY2lwYW50S2V5SGFuZGxlciB9IGZyb20gJy4vUGFydGljaXBhbnRLZXlIYW5kbGVyJztcbmltcG9ydCB7IFNpZkd1YXJkIH0gZnJvbSAnLi9TaWZHdWFyZCc7XG5cbmV4cG9ydCBjb25zdCBlbmNyeXB0aW9uRW5hYmxlZE1hcDogTWFwPHN0cmluZywgYm9vbGVhbj4gPSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRnJhbWVDcnlwdG9yQ29uc3RydWN0b3Ige1xuICBuZXcgKG9wdHM/OiB1bmtub3duKTogQmFzZUZyYW1lQ3J5cHRvcjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2Zvcm1lckluZm8ge1xuICByZWFkYWJsZTogUmVhZGFibGVTdHJlYW07XG4gIHdyaXRhYmxlOiBXcml0YWJsZVN0cmVhbTtcbiAgdHJhbnNmb3JtZXI6IFRyYW5zZm9ybVN0cmVhbTtcbiAgYWJvcnRDb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBCYXNlRnJhbWVDcnlwdG9yIGV4dGVuZHMgKEV2ZW50RW1pdHRlciBhcyBuZXcgKCkgPT4gVHlwZWRFdmVudEVtaXR0ZXI8Q3J5cHRvckNhbGxiYWNrcz4pIHtcbiAgcHJvdGVjdGVkIGVuY29kZUZ1bmN0aW9uKFxuICAgIGVuY29kZWRGcmFtZTogUlRDRW5jb2RlZFZpZGVvRnJhbWUgfCBSVENFbmNvZGVkQXVkaW9GcmFtZSxcbiAgICBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aHJvdyBFcnJvcignbm90IGltcGxlbWVudGVkIGZvciBzdWJjbGFzcycpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGRlY29kZUZ1bmN0aW9uKFxuICAgIGVuY29kZWRGcmFtZTogUlRDRW5jb2RlZFZpZGVvRnJhbWUgfCBSVENFbmNvZGVkQXVkaW9GcmFtZSxcbiAgICBjb250cm9sbGVyOiBUcmFuc2Zvcm1TdHJlYW1EZWZhdWx0Q29udHJvbGxlcixcbiAgKTogUHJvbWlzZTxhbnk+IHtcbiAgICB0aHJvdyBFcnJvcignbm90IGltcGxlbWVudGVkIGZvciBzdWJjbGFzcycpO1xuICB9XG59XG5cbi8qKlxuICogQ3J5cHRvciBpcyByZXNwb25zaWJsZSBmb3IgZW4tL2RlY3J5cHRpbmcgbWVkaWEgZnJhbWVzLlxuICogRWFjaCBDcnlwdG9yIGluc3RhbmNlIGlzIHJlc3BvbnNpYmxlIGZvciBlbi0vZGVjcnlwdGluZyBhIHNpbmdsZSBtZWRpYVN0cmVhbVRyYWNrLlxuICovXG5leHBvcnQgY2xhc3MgRnJhbWVDcnlwdG9yIGV4dGVuZHMgQmFzZUZyYW1lQ3J5cHRvciB7XG4gIHByaXZhdGUgc2VuZENvdW50czogTWFwPG51bWJlciwgbnVtYmVyPjtcblxuICBwcml2YXRlIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIHRyYWNrSWQ6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGtleXM6IFBhcnRpY2lwYW50S2V5SGFuZGxlcjtcblxuICBwcml2YXRlIHZpZGVvQ29kZWM/OiBWaWRlb0NvZGVjO1xuXG4gIHByaXZhdGUgcnRwTWFwOiBNYXA8bnVtYmVyLCBWaWRlb0NvZGVjPjtcblxuICBwcml2YXRlIGtleVByb3ZpZGVyT3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zO1xuXG4gIC8qKlxuICAgKiB1c2VkIGZvciBkZXRlY3Rpbmcgc2VydmVyIGluamVjdGVkIHVuZW5jcnlwdGVkIGZyYW1lc1xuICAgKi9cbiAgcHJpdmF0ZSBzaWZUcmFpbGVyOiBVaW50OEFycmF5O1xuXG4gIHByaXZhdGUgc2lmR3VhcmQ6IFNpZkd1YXJkO1xuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IHtcbiAgICBrZXlzOiBQYXJ0aWNpcGFudEtleUhhbmRsZXI7XG4gICAgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nO1xuICAgIGtleVByb3ZpZGVyT3B0aW9uczogS2V5UHJvdmlkZXJPcHRpb25zO1xuICAgIHNpZlRyYWlsZXI/OiBVaW50OEFycmF5O1xuICB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnNlbmRDb3VudHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXlzID0gb3B0cy5rZXlzO1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IG9wdHMucGFydGljaXBhbnRJZGVudGl0eTtcbiAgICB0aGlzLnJ0cE1hcCA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucyA9IG9wdHMua2V5UHJvdmlkZXJPcHRpb25zO1xuICAgIHRoaXMuc2lmVHJhaWxlciA9IG9wdHMuc2lmVHJhaWxlciA/PyBVaW50OEFycmF5LmZyb20oW10pO1xuICAgIHRoaXMuc2lmR3VhcmQgPSBuZXcgU2lmR3VhcmQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBc3NpZ24gYSBkaWZmZXJlbnQgcGFydGljaXBhbnQgdG8gdGhlIGNyeXB0b3IuXG4gICAqIHVzZWZ1bCBmb3IgdHJhbnNjZWl2ZXIgcmUtdXNlXG4gICAqIEBwYXJhbSBpZFxuICAgKiBAcGFyYW0ga2V5c1xuICAgKi9cbiAgc2V0UGFydGljaXBhbnQoaWQ6IHN0cmluZywga2V5czogUGFydGljaXBhbnRLZXlIYW5kbGVyKSB7XG4gICAgdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5ID0gaWQ7XG4gICAgdGhpcy5rZXlzID0ga2V5cztcbiAgICB0aGlzLnNpZkd1YXJkLnJlc2V0KCk7XG4gIH1cblxuICB1bnNldFBhcnRpY2lwYW50KCkge1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlzRW5hYmxlZCgpIHtcbiAgICBpZiAodGhpcy5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICByZXR1cm4gZW5jcnlwdGlvbkVuYWJsZWRNYXAuZ2V0KHRoaXMucGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0UGFydGljaXBhbnRJZGVudGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJ0aWNpcGFudElkZW50aXR5O1xuICB9XG5cbiAgZ2V0VHJhY2tJZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja0lkO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgdmlkZW8gY29kZWMgdXNlZCBieSB0aGUgbWVkaWFTdHJlYW1UcmFja1xuICAgKiBAcGFyYW0gY29kZWNcbiAgICovXG4gIHNldFZpZGVvQ29kZWMoY29kZWM6IFZpZGVvQ29kZWMpIHtcbiAgICB0aGlzLnZpZGVvQ29kZWMgPSBjb2RlYztcbiAgfVxuXG4gIC8qKlxuICAgKiBydHAgcGF5bG9hZCB0eXBlIG1hcCB1c2VkIGZvciBmaWd1cmluZyBvdXQgY29kZWMgb2YgcGF5bG9hZCB0eXBlIHdoZW4gZW5jb2RpbmdcbiAgICogQHBhcmFtIG1hcFxuICAgKi9cbiAgc2V0UnRwTWFwKG1hcDogTWFwPG51bWJlciwgVmlkZW9Db2RlYz4pIHtcbiAgICB0aGlzLnJ0cE1hcCA9IG1hcDtcbiAgfVxuXG4gIHNldHVwVHJhbnNmb3JtKFxuICAgIG9wZXJhdGlvbjogJ2VuY29kZScgfCAnZGVjb2RlJyxcbiAgICByZWFkYWJsZTogUmVhZGFibGVTdHJlYW0sXG4gICAgd3JpdGFibGU6IFdyaXRhYmxlU3RyZWFtLFxuICAgIHRyYWNrSWQ6IHN0cmluZyxcbiAgICBjb2RlYz86IFZpZGVvQ29kZWMsXG4gICkge1xuICAgIGlmIChjb2RlYykge1xuICAgICAgd29ya2VyTG9nZ2VyLmluZm8oJ3NldHRpbmcgY29kZWMgb24gY3J5cHRvciB0bycsIHsgY29kZWMgfSk7XG4gICAgICB0aGlzLnZpZGVvQ29kZWMgPSBjb2RlYztcbiAgICB9XG5cbiAgICBjb25zdCB0cmFuc2Zvcm1GbiA9IG9wZXJhdGlvbiA9PT0gJ2VuY29kZScgPyB0aGlzLmVuY29kZUZ1bmN0aW9uIDogdGhpcy5kZWNvZGVGdW5jdGlvbjtcbiAgICBjb25zdCB0cmFuc2Zvcm1TdHJlYW0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtRm4uYmluZCh0aGlzKSxcbiAgICB9KTtcblxuICAgIHJlYWRhYmxlXG4gICAgICAucGlwZVRocm91Z2godHJhbnNmb3JtU3RyZWFtKVxuICAgICAgLnBpcGVUbyh3cml0YWJsZSlcbiAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICB3b3JrZXJMb2dnZXIud2FybihlKTtcbiAgICAgICAgdGhpcy5lbWl0KENyeXB0b3JFdmVudC5FcnJvciwgZSBpbnN0YW5jZW9mIENyeXB0b3JFcnJvciA/IGUgOiBuZXcgQ3J5cHRvckVycm9yKGUubWVzc2FnZSkpO1xuICAgICAgfSk7XG4gICAgdGhpcy50cmFja0lkID0gdHJhY2tJZDtcbiAgfVxuXG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcjogVWludDhBcnJheSkge1xuICAgIHRoaXMuc2lmVHJhaWxlciA9IHRyYWlsZXI7XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGluamVjdGVkIGluIGEgc3RyZWFtIGFuZCB3aWxsIGVuY3J5cHQgdGhlIGdpdmVuIGVuY29kZWQgZnJhbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0VuY29kZWRWaWRlb0ZyYW1lfFJUQ0VuY29kZWRBdWRpb0ZyYW1lfSBlbmNvZGVkRnJhbWUgLSBFbmNvZGVkIHZpZGVvIGZyYW1lLlxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyIC0gVHJhbnNwb3J0U3RyZWFtQ29udHJvbGxlci5cbiAgICpcbiAgICogVGhlIFZQOCBwYXlsb2FkIGRlc2NyaXB0b3IgZGVzY3JpYmVkIGluXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NzQxI3NlY3Rpb24tNC4yXG4gICAqIGlzIHBhcnQgb2YgdGhlIFJUUCBwYWNrZXQgYW5kIG5vdCBwYXJ0IG9mIHRoZSBmcmFtZSBhbmQgaXMgbm90IGNvbnRyb2xsYWJsZSBieSB1cy5cbiAgICogVGhpcyBpcyBmaW5lIGFzIHRoZSBTRlUga2VlcHMgaGF2aW5nIGFjY2VzcyB0byBpdCBmb3Igcm91dGluZy5cbiAgICpcbiAgICogVGhlIGVuY3J5cHRlZCBmcmFtZSBpcyBmb3JtZWQgYXMgZm9sbG93czpcbiAgICogMSkgRmluZCB1bmVuY3J5cHRlZCBieXRlIGxlbmd0aCwgZGVwZW5kaW5nIG9uIHRoZSBjb2RlYywgZnJhbWUgdHlwZSBhbmQga2luZC5cbiAgICogMikgRm9ybSB0aGUgR0NNIElWIGZvciB0aGUgZnJhbWUgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKiAzKSBFbmNyeXB0IHRoZSByZXN0IG9mIHRoZSBmcmFtZSB1c2luZyBBRVMtR0NNLlxuICAgKiA0KSBBbGxvY2F0ZSBzcGFjZSBmb3IgdGhlIGVuY3J5cHRlZCBmcmFtZS5cbiAgICogNSkgQ29weSB0aGUgdW5lbmNyeXB0ZWQgYnl0ZXMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBlbmNyeXB0ZWQgZnJhbWUuXG4gICAqIDYpIEFwcGVuZCB0aGUgY2lwaGVydGV4dCB0byB0aGUgZW5jcnlwdGVkIGZyYW1lLlxuICAgKiA3KSBBcHBlbmQgdGhlIElWLlxuICAgKiA4KSBBcHBlbmQgYSBzaW5nbGUgYnl0ZSBmb3IgdGhlIGtleSBpZGVudGlmaWVyLlxuICAgKiA5KSBFbnF1ZXVlIHRoZSBlbmNyeXB0ZWQgZnJhbWUgZm9yIHNlbmRpbmcuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgZW5jb2RlRnVuY3Rpb24oXG4gICAgZW5jb2RlZEZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSB8IFJUQ0VuY29kZWRBdWRpb0ZyYW1lLFxuICAgIGNvbnRyb2xsZXI6IFRyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyLFxuICApIHtcbiAgICBpZiAoXG4gICAgICAhdGhpcy5pc0VuYWJsZWQoKSB8fFxuICAgICAgLy8gc2tpcCBmb3IgZW5jcnlwdGlvbiBmb3IgZW1wdHkgZHR4IGZyYW1lc1xuICAgICAgZW5jb2RlZEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCA9PT0gMFxuICAgICkge1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRnJhbWUpO1xuICAgIH1cbiAgICBjb25zdCBrZXlTZXQgPSB0aGlzLmtleXMuZ2V0S2V5U2V0KCk7XG4gICAgaWYgKCFrZXlTZXQpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBrZXkgc2V0IG5vdCBmb3VuZCBmb3IgJHtcbiAgICAgICAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgfSBhdCBpbmRleCAke3RoaXMua2V5cy5nZXRDdXJyZW50S2V5SW5kZXgoKX1gLFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgeyBlbmNyeXB0aW9uS2V5IH0gPSBrZXlTZXQ7XG4gICAgY29uc3Qga2V5SW5kZXggPSB0aGlzLmtleXMuZ2V0Q3VycmVudEtleUluZGV4KCk7XG5cbiAgICBpZiAoZW5jcnlwdGlvbktleSkge1xuICAgICAgY29uc3QgaXYgPSB0aGlzLm1ha2VJVihcbiAgICAgICAgZW5jb2RlZEZyYW1lLmdldE1ldGFkYXRhKCkuc3luY2hyb25pemF0aW9uU291cmNlID8/IC0xLFxuICAgICAgICBlbmNvZGVkRnJhbWUudGltZXN0YW1wLFxuICAgICAgKTtcblxuICAgICAgLy8gVGjRlnMgaXMgbm90IGVuY3J5cHRlZCBhbmQgY29udGFpbnMgdGhlIFZQOCBwYXlsb2FkIGRlc2NyaXB0b3Igb3IgdGhlIE9wdXMgVE9DIGJ5dGUuXG4gICAgICBjb25zdCBmcmFtZUhlYWRlciA9IG5ldyBVaW50OEFycmF5KFxuICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YSxcbiAgICAgICAgMCxcbiAgICAgICAgdGhpcy5nZXRVbmVuY3J5cHRlZEJ5dGVzKGVuY29kZWRGcmFtZSksXG4gICAgICApO1xuXG4gICAgICAvLyBGcmFtZSB0cmFpbGVyIGNvbnRhaW5zIHRoZSBSfElWX0xFTkdUSCBhbmQga2V5IGluZGV4XG4gICAgICBjb25zdCBmcmFtZVRyYWlsZXIgPSBuZXcgVWludDhBcnJheSgyKTtcblxuICAgICAgZnJhbWVUcmFpbGVyWzBdID0gSVZfTEVOR1RIO1xuICAgICAgZnJhbWVUcmFpbGVyWzFdID0ga2V5SW5kZXg7XG5cbiAgICAgIC8vIENvbnN0cnVjdCBmcmFtZSB0cmFpbGVyLiBTaW1pbGFyIHRvIHRoZSBmcmFtZSBoZWFkZXIgZGVzY3JpYmVkIGluXG4gICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtb21hcmEtc2ZyYW1lLTAwI3NlY3Rpb24tNC4yXG4gICAgICAvLyBidXQgd2UgcHV0IGl0IGF0IHRoZSBlbmQuXG4gICAgICAvL1xuICAgICAgLy8gLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLSstLS0tLS0tLS0rLS0tLVxuICAgICAgLy8gcGF5bG9hZCAgfElWLi4uKGxlbmd0aCA9IElWX0xFTkdUSCl8UnxJVl9MRU5HVEh8S0lEIHxcbiAgICAgIC8vIC0tLS0tLS0tLSstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0rLS0tLS0tLS0tKy0tLS1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNpcGhlclRleHQgPSBhd2FpdCBjcnlwdG8uc3VidGxlLmVuY3J5cHQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogRU5DUllQVElPTl9BTEdPUklUSE0sXG4gICAgICAgICAgICBpdixcbiAgICAgICAgICAgIGFkZGl0aW9uYWxEYXRhOiBuZXcgVWludDhBcnJheShlbmNvZGVkRnJhbWUuZGF0YSwgMCwgZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aCksXG4gICAgICAgICAgfSxcbiAgICAgICAgICBlbmNyeXB0aW9uS2V5LFxuICAgICAgICAgIG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhLCB0aGlzLmdldFVuZW5jcnlwdGVkQnl0ZXMoZW5jb2RlZEZyYW1lKSksXG4gICAgICAgICk7XG5cbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IG5ldyBBcnJheUJ1ZmZlcihcbiAgICAgICAgICBmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgY2lwaGVyVGV4dC5ieXRlTGVuZ3RoICsgaXYuYnl0ZUxlbmd0aCArIGZyYW1lVHJhaWxlci5ieXRlTGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICBjb25zdCBuZXdVaW50OCA9IG5ldyBVaW50OEFycmF5KG5ld0RhdGEpO1xuXG4gICAgICAgIG5ld1VpbnQ4LnNldChmcmFtZUhlYWRlcik7IC8vIGNvcHkgZmlyc3QgYnl0ZXMuXG4gICAgICAgIG5ld1VpbnQ4LnNldChuZXcgVWludDhBcnJheShjaXBoZXJUZXh0KSwgZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aCk7IC8vIGFkZCBjaXBoZXJ0ZXh0LlxuICAgICAgICBuZXdVaW50OC5zZXQobmV3IFVpbnQ4QXJyYXkoaXYpLCBmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgY2lwaGVyVGV4dC5ieXRlTGVuZ3RoKTsgLy8gYXBwZW5kIElWLlxuICAgICAgICBuZXdVaW50OC5zZXQoZnJhbWVUcmFpbGVyLCBmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgY2lwaGVyVGV4dC5ieXRlTGVuZ3RoICsgaXYuYnl0ZUxlbmd0aCk7IC8vIGFwcGVuZCBmcmFtZSB0cmFpbGVyLlxuXG4gICAgICAgIGVuY29kZWRGcmFtZS5kYXRhID0gbmV3RGF0YTtcblxuICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZWRGcmFtZSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgLy8gVE9ETzogc3VyZmFjZSB0aGlzIHRvIHRoZSBhcHAuXG4gICAgICAgIHdvcmtlckxvZ2dlci5lcnJvcihlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KFxuICAgICAgICBDcnlwdG9yRXZlbnQuRXJyb3IsXG4gICAgICAgIG5ldyBDcnlwdG9yRXJyb3IoYGVuY3J5cHRpb24ga2V5IG1pc3NpbmcgZm9yIGVuY29kaW5nYCwgQ3J5cHRvckVycm9yUmVhc29uLk1pc3NpbmdLZXkpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGluamVjdGVkIGluIGEgc3RyZWFtIGFuZCB3aWxsIGRlY3J5cHQgdGhlIGdpdmVuIGVuY29kZWQgZnJhbWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JUQ0VuY29kZWRWaWRlb0ZyYW1lfFJUQ0VuY29kZWRBdWRpb0ZyYW1lfSBlbmNvZGVkRnJhbWUgLSBFbmNvZGVkIHZpZGVvIGZyYW1lLlxuICAgKiBAcGFyYW0ge1RyYW5zZm9ybVN0cmVhbURlZmF1bHRDb250cm9sbGVyfSBjb250cm9sbGVyIC0gVHJhbnNwb3J0U3RyZWFtQ29udHJvbGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBkZWNvZGVGdW5jdGlvbihcbiAgICBlbmNvZGVkRnJhbWU6IFJUQ0VuY29kZWRWaWRlb0ZyYW1lIHwgUlRDRW5jb2RlZEF1ZGlvRnJhbWUsXG4gICAgY29udHJvbGxlcjogVHJhbnNmb3JtU3RyZWFtRGVmYXVsdENvbnRyb2xsZXIsXG4gICkge1xuICAgIGlmIChcbiAgICAgICF0aGlzLmlzRW5hYmxlZCgpIHx8XG4gICAgICAvLyBza2lwIGZvciBkZWNyeXB0aW9uIGZvciBlbXB0eSBkdHggZnJhbWVzXG4gICAgICBlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoID09PSAwXG4gICAgKSB7XG4gICAgICB0aGlzLnNpZkd1YXJkLnJlY29yZFVzZXJGcmFtZSgpO1xuICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVkRnJhbWUpO1xuICAgIH1cblxuICAgIGlmIChpc0ZyYW1lU2VydmVySW5qZWN0ZWQoZW5jb2RlZEZyYW1lLmRhdGEsIHRoaXMuc2lmVHJhaWxlcikpIHtcbiAgICAgIHRoaXMuc2lmR3VhcmQucmVjb3JkU2lmKCk7XG5cbiAgICAgIGlmICh0aGlzLnNpZkd1YXJkLmlzU2lmQWxsb3dlZCgpKSB7XG4gICAgICAgIGVuY29kZWRGcmFtZS5kYXRhID0gZW5jb2RlZEZyYW1lLmRhdGEuc2xpY2UoXG4gICAgICAgICAgMCxcbiAgICAgICAgICBlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoIC0gdGhpcy5zaWZUcmFpbGVyLmJ5dGVMZW5ndGgsXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBjb250cm9sbGVyLmVucXVldWUoZW5jb2RlZEZyYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtlckxvZ2dlci53YXJuKCdTSUYgbGltaXQgcmVhY2hlZCwgZHJvcHBpbmcgZnJhbWUnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNpZkd1YXJkLnJlY29yZFVzZXJGcmFtZSgpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEZyYW1lLmRhdGEpO1xuICAgIGNvbnN0IGtleUluZGV4ID0gZGF0YVtlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoIC0gMV07XG5cbiAgICBpZiAodGhpcy5rZXlzLmdldEtleVNldChrZXlJbmRleCkgJiYgdGhpcy5rZXlzLmhhc1ZhbGlkS2V5KSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVkRnJhbWUgPSBhd2FpdCB0aGlzLmRlY3J5cHRGcmFtZShlbmNvZGVkRnJhbWUsIGtleUluZGV4KTtcbiAgICAgICAgdGhpcy5rZXlzLmRlY3J5cHRpb25TdWNjZXNzKCk7XG4gICAgICAgIGlmIChkZWNvZGVkRnJhbWUpIHtcbiAgICAgICAgICByZXR1cm4gY29udHJvbGxlci5lbnF1ZXVlKGRlY29kZWRGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENyeXB0b3JFcnJvciAmJiBlcnJvci5yZWFzb24gPT09IENyeXB0b3JFcnJvclJlYXNvbi5JbnZhbGlkS2V5KSB7XG4gICAgICAgICAgaWYgKHRoaXMua2V5cy5oYXNWYWxpZEtleSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KENyeXB0b3JFdmVudC5FcnJvciwgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5rZXlzLmRlY3J5cHRpb25GYWlsdXJlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdvcmtlckxvZ2dlci53YXJuKCdkZWNvZGluZyBmcmFtZSBmYWlsZWQnLCB7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5rZXlzLmdldEtleVNldChrZXlJbmRleCkgJiYgdGhpcy5rZXlzLmhhc1ZhbGlkS2V5KSB7XG4gICAgICAvLyBlbWl0IGFuIGVycm9yIGluIGNhc2UgdGhlIGtleSBpbmRleCBpcyBvdXQgb2YgYm91bmRzIGJ1dCB0aGUga2V5IGhhbmRsZXIgdGhpbmtzIHdlIHN0aWxsIGhhdmUgYSB2YWxpZCBrZXlcbiAgICAgIHdvcmtlckxvZ2dlci53YXJuKCdza2lwcGluZyBkZWNyeXB0aW9uIGR1ZSB0byBtaXNzaW5nIGtleSBhdCBpbmRleCcpO1xuICAgICAgdGhpcy5lbWl0KFxuICAgICAgICBDcnlwdG9yRXZlbnQuRXJyb3IsXG4gICAgICAgIG5ldyBDcnlwdG9yRXJyb3IoXG4gICAgICAgICAgYG1pc3Npbmcga2V5IGF0IGluZGV4IGZvciBwYXJ0aWNpcGFudCAke3RoaXMucGFydGljaXBhbnRJZGVudGl0eX1gLFxuICAgICAgICAgIENyeXB0b3JFcnJvclJlYXNvbi5NaXNzaW5nS2V5LFxuICAgICAgICApLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGRlY3J5cHQgdGhlIGdpdmVuIGVuY29kZWQgZnJhbWUuIElmIHRoZSBkZWNyeXB0aW9uIGZhaWxzLCBpdCB3aWxsXG4gICAqIHJhdGNoZXQgdGhlIGtleSBmb3IgdXAgdG8gUkFUQ0hFVF9XSU5ET1dfU0laRSB0aW1lcy5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZGVjcnlwdEZyYW1lKFxuICAgIGVuY29kZWRGcmFtZTogUlRDRW5jb2RlZFZpZGVvRnJhbWUgfCBSVENFbmNvZGVkQXVkaW9GcmFtZSxcbiAgICBrZXlJbmRleDogbnVtYmVyLFxuICAgIGluaXRpYWxNYXRlcmlhbDogS2V5U2V0IHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkLFxuICAgIHJhdGNoZXRPcHRzOiBEZWNvZGVSYXRjaGV0T3B0aW9ucyA9IHsgcmF0Y2hldENvdW50OiAwIH0sXG4gICk6IFByb21pc2U8UlRDRW5jb2RlZFZpZGVvRnJhbWUgfCBSVENFbmNvZGVkQXVkaW9GcmFtZSB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGtleVNldCA9IHRoaXMua2V5cy5nZXRLZXlTZXQoa2V5SW5kZXgpO1xuICAgIGlmICghcmF0Y2hldE9wdHMuZW5jcnlwdGlvbktleSAmJiAha2V5U2V0KSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBubyBlbmNyeXB0aW9uIGtleSBmb3VuZCBmb3IgZGVjcnlwdGlvbiBvZiAke3RoaXMucGFydGljaXBhbnRJZGVudGl0eX1gKTtcbiAgICB9XG5cbiAgICAvLyBDb25zdHJ1Y3QgZnJhbWUgdHJhaWxlci4gU2ltaWxhciB0byB0aGUgZnJhbWUgaGVhZGVyIGRlc2NyaWJlZCBpblxuICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjJcbiAgICAvLyBidXQgd2UgcHV0IGl0IGF0IHRoZSBlbmQuXG4gICAgLy9cbiAgICAvLyAtLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstKy0tLS0tLS0tLSstLS0tXG4gICAgLy8gcGF5bG9hZCAgfElWLi4uKGxlbmd0aCA9IElWX0xFTkdUSCl8UnxJVl9MRU5HVEh8S0lEIHxcbiAgICAvLyAtLS0tLS0tLS0rLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSstKy0tLS0tLS0tLSstLS0tXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZnJhbWVIZWFkZXIgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgZW5jb2RlZEZyYW1lLmRhdGEsXG4gICAgICAgIDAsXG4gICAgICAgIHRoaXMuZ2V0VW5lbmNyeXB0ZWRCeXRlcyhlbmNvZGVkRnJhbWUpLFxuICAgICAgKTtcbiAgICAgIGNvbnN0IGZyYW1lVHJhaWxlciA9IG5ldyBVaW50OEFycmF5KGVuY29kZWRGcmFtZS5kYXRhLCBlbmNvZGVkRnJhbWUuZGF0YS5ieXRlTGVuZ3RoIC0gMiwgMik7XG5cbiAgICAgIGNvbnN0IGl2TGVuZ3RoID0gZnJhbWVUcmFpbGVyWzBdO1xuICAgICAgY29uc3QgaXYgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgZW5jb2RlZEZyYW1lLmRhdGEsXG4gICAgICAgIGVuY29kZWRGcmFtZS5kYXRhLmJ5dGVMZW5ndGggLSBpdkxlbmd0aCAtIGZyYW1lVHJhaWxlci5ieXRlTGVuZ3RoLFxuICAgICAgICBpdkxlbmd0aCxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IGNpcGhlclRleHRTdGFydCA9IGZyYW1lSGVhZGVyLmJ5dGVMZW5ndGg7XG4gICAgICBjb25zdCBjaXBoZXJUZXh0TGVuZ3RoID1cbiAgICAgICAgZW5jb2RlZEZyYW1lLmRhdGEuYnl0ZUxlbmd0aCAtXG4gICAgICAgIChmcmFtZUhlYWRlci5ieXRlTGVuZ3RoICsgaXZMZW5ndGggKyBmcmFtZVRyYWlsZXIuYnl0ZUxlbmd0aCk7XG5cbiAgICAgIGNvbnN0IHBsYWluVGV4dCA9IGF3YWl0IGNyeXB0by5zdWJ0bGUuZGVjcnlwdChcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgICAgIGl2LFxuICAgICAgICAgIGFkZGl0aW9uYWxEYXRhOiBuZXcgVWludDhBcnJheShlbmNvZGVkRnJhbWUuZGF0YSwgMCwgZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aCksXG4gICAgICAgIH0sXG4gICAgICAgIHJhdGNoZXRPcHRzLmVuY3J5cHRpb25LZXkgPz8ga2V5U2V0IS5lbmNyeXB0aW9uS2V5LFxuICAgICAgICBuZXcgVWludDhBcnJheShlbmNvZGVkRnJhbWUuZGF0YSwgY2lwaGVyVGV4dFN0YXJ0LCBjaXBoZXJUZXh0TGVuZ3RoKSxcbiAgICAgICk7XG5cbiAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgQXJyYXlCdWZmZXIoZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aCArIHBsYWluVGV4dC5ieXRlTGVuZ3RoKTtcbiAgICAgIGNvbnN0IG5ld1VpbnQ4ID0gbmV3IFVpbnQ4QXJyYXkobmV3RGF0YSk7XG5cbiAgICAgIG5ld1VpbnQ4LnNldChuZXcgVWludDhBcnJheShlbmNvZGVkRnJhbWUuZGF0YSwgMCwgZnJhbWVIZWFkZXIuYnl0ZUxlbmd0aCkpO1xuICAgICAgbmV3VWludDguc2V0KG5ldyBVaW50OEFycmF5KHBsYWluVGV4dCksIGZyYW1lSGVhZGVyLmJ5dGVMZW5ndGgpO1xuXG4gICAgICBlbmNvZGVkRnJhbWUuZGF0YSA9IG5ld0RhdGE7XG5cbiAgICAgIHJldHVybiBlbmNvZGVkRnJhbWU7XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgaWYgKHRoaXMua2V5UHJvdmlkZXJPcHRpb25zLnJhdGNoZXRXaW5kb3dTaXplID4gMCkge1xuICAgICAgICBpZiAocmF0Y2hldE9wdHMucmF0Y2hldENvdW50IDwgdGhpcy5rZXlQcm92aWRlck9wdGlvbnMucmF0Y2hldFdpbmRvd1NpemUpIHtcbiAgICAgICAgICB3b3JrZXJMb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgcmF0Y2hldGluZyBrZXkgYXR0ZW1wdCAke3JhdGNoZXRPcHRzLnJhdGNoZXRDb3VudH0gb2YgJHtcbiAgICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlck9wdGlvbnMucmF0Y2hldFdpbmRvd1NpemVcbiAgICAgICAgICAgIH0sIGZvciBraW5kICR7ZW5jb2RlZEZyYW1lIGluc3RhbmNlb2YgUlRDRW5jb2RlZEF1ZGlvRnJhbWUgPyAnYXVkaW8nIDogJ3ZpZGVvJ31gLFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBsZXQgcmF0Y2hldGVkS2V5U2V0OiBLZXlTZXQgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgaWYgKGtleVNldCA9PT0gdGhpcy5rZXlzLmdldEtleVNldChrZXlJbmRleCkpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgcmF0Y2hldCBpZiB0aGUgY3VycmVudGx5IHNldCBrZXkgaXMgc3RpbGwgdGhlIHNhbWUgYXMgdGhlIG9uZSB1c2VkIHRvIGRlY3J5cHQgdGhpcyBmcmFtZVxuICAgICAgICAgICAgLy8gaWYgbm90LCBpdCBtaWdodCBiZSB0aGF0IGEgZGlmZmVyZW50IGZyYW1lIGhhcyBhbHJlYWR5IHJhdGNoZXRlZCBhbmQgd2UgdHJ5IHdpdGggdGhhdCBvbmUgZmlyc3RcbiAgICAgICAgICAgIGNvbnN0IG5ld01hdGVyaWFsID0gYXdhaXQgdGhpcy5rZXlzLnJhdGNoZXRLZXkoa2V5SW5kZXgsIGZhbHNlKTtcblxuICAgICAgICAgICAgcmF0Y2hldGVkS2V5U2V0ID0gYXdhaXQgZGVyaXZlS2V5cyhuZXdNYXRlcmlhbCwgdGhpcy5rZXlQcm92aWRlck9wdGlvbnMucmF0Y2hldFNhbHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IGZyYW1lID0gYXdhaXQgdGhpcy5kZWNyeXB0RnJhbWUoZW5jb2RlZEZyYW1lLCBrZXlJbmRleCwgaW5pdGlhbE1hdGVyaWFsIHx8IGtleVNldCwge1xuICAgICAgICAgICAgcmF0Y2hldENvdW50OiByYXRjaGV0T3B0cy5yYXRjaGV0Q291bnQgKyAxLFxuICAgICAgICAgICAgZW5jcnlwdGlvbktleTogcmF0Y2hldGVkS2V5U2V0Py5lbmNyeXB0aW9uS2V5LFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChmcmFtZSAmJiByYXRjaGV0ZWRLZXlTZXQpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5zZXRLZXlTZXQocmF0Y2hldGVkS2V5U2V0LCBrZXlJbmRleCwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBkZWNyeXB0aW9uIHdhcyBzdWNjZXNzZnVsLCBzZXQgdGhlIG5ldyBrZXkgaW5kZXggdG8gcmVmbGVjdCB0aGUgcmF0Y2hldGVkIGtleSBzZXRcbiAgICAgICAgICAgIHRoaXMua2V5cy5zZXRDdXJyZW50S2V5SW5kZXgoa2V5SW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZnJhbWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogU2luY2UgdGhlIGtleSBpdCBpcyBmaXJzdCBzZW5kIGFuZCBvbmx5IGFmdGVyd2FyZHMgYWN0dWFsbHkgdXNlZCBmb3IgZW5jcnlwdGluZywgdGhlcmUgd2VyZVxuICAgICAgICAgICAqIHNpdHVhdGlvbnMgd2hlbiB0aGUgZGVjcnlwdGluZyBmYWlsZWQgZHVlIHRvIHRoZSBmYWN0IHRoYXQgdGhlIHJlY2VpdmVkIGZyYW1lIHdhcyBub3QgZW5jcnlwdGVkXG4gICAgICAgICAgICogeWV0IGFuZCByYXRjaGV0aW5nLCBvZiBjb3Vyc2UsIGRpZCBub3Qgc29sdmUgdGhlIHByb2JsZW0uIFNvIGlmIHdlIGZhaWwgUkFUQ0hFVF9XSU5ET1dfU0laRSB0aW1lcyxcbiAgICAgICAgICAgKiB3ZSBjb21lIGJhY2sgdG8gdGhlIGluaXRpYWwga2V5LlxuICAgICAgICAgICAqL1xuICAgICAgICAgIGlmIChpbml0aWFsTWF0ZXJpYWwpIHtcbiAgICAgICAgICAgIHdvcmtlckxvZ2dlci5kZWJ1ZygncmVzZXR0aW5nIHRvIGluaXRpYWwgbWF0ZXJpYWwnKTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5zZXRLZXlGcm9tTWF0ZXJpYWwoaW5pdGlhbE1hdGVyaWFsLm1hdGVyaWFsLCBrZXlJbmRleCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgd29ya2VyTG9nZ2VyLndhcm4oJ21heGltdW0gcmF0Y2hldCBhdHRlbXB0cyBleGNlZWRlZCcpO1xuICAgICAgICAgIHRocm93IG5ldyBDcnlwdG9yRXJyb3IoXG4gICAgICAgICAgICBgdmFsaWQga2V5IG1pc3NpbmcgZm9yIHBhcnRpY2lwYW50ICR7dGhpcy5wYXJ0aWNpcGFudElkZW50aXR5fWAsXG4gICAgICAgICAgICBDcnlwdG9yRXJyb3JSZWFzb24uSW52YWxpZEtleSxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQ3J5cHRvckVycm9yKFxuICAgICAgICAgIGBEZWNyeXB0aW9uIGZhaWxlZDogJHtlcnJvci5tZXNzYWdlfWAsXG4gICAgICAgICAgQ3J5cHRvckVycm9yUmVhc29uLkludmFsaWRLZXksXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCB0aGUgSVYgdXNlZCBmb3IgQUVTLUdDTSBhbmQgc2VudCAoaW4gcGxhaW4pIHdpdGggdGhlIHBhY2tldCBzaW1pbGFyIHRvXG4gICAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3NzE0I3NlY3Rpb24tOC4xXG4gICAqIEl0IGNvbmNhdGVuYXRlc1xuICAgKiAtIHRoZSAzMiBiaXQgc3luY2hyb25pemF0aW9uIHNvdXJjZSAoU1NSQykgZ2l2ZW4gb24gdGhlIGVuY29kZWQgZnJhbWUsXG4gICAqIC0gdGhlIDMyIGJpdCBydHAgdGltZXN0YW1wIGdpdmVuIG9uIHRoZSBlbmNvZGVkIGZyYW1lLFxuICAgKiAtIGEgc2VuZCBjb3VudGVyIHRoYXQgaXMgc3BlY2lmaWMgdG8gdGhlIFNTUkMuIFN0YXJ0cyBhdCBhIHJhbmRvbSBudW1iZXIuXG4gICAqIFRoZSBzZW5kIGNvdW50ZXIgaXMgZXNzZW50aWFsbHkgdGhlIHBpY3R1cmVJZCBidXQgd2UgY3VycmVudGx5IGhhdmUgdG8gaW1wbGVtZW50IHRoaXMgb3Vyc2VsdmVzLlxuICAgKiBUaGVyZSBpcyBubyBYT1Igd2l0aCBhIHNhbHQuIE5vdGUgdGhhdCB0aGlzIElWIGxlYWtzIHRoZSBTU1JDIHRvIHRoZSByZWNlaXZlciBidXQgc2luY2UgdGhpcyBpc1xuICAgKiByYW5kb21seSBnZW5lcmF0ZWQgYW5kIFNGVXMgbWF5IG5vdCByZXdyaXRlIHRoaXMgaXMgY29uc2lkZXJlZCBhY2NlcHRhYmxlLlxuICAgKiBUaGUgU1NSQyBpcyB1c2VkIHRvIGFsbG93IGRlbXVsdGlwbGV4aW5nIG11bHRpcGxlIHN0cmVhbXMgd2l0aCB0aGUgc2FtZSBrZXksIGFzIGRlc2NyaWJlZCBpblxuICAgKiAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNzExI3NlY3Rpb24tNC4xLjFcbiAgICogVGhlIFJUUCB0aW1lc3RhbXAgaXMgMzIgYml0cyBhbmQgYWR2YW5jZXMgYnkgdGhlIGNvZGVjIGNsb2NrIHJhdGUgKDkwa2h6IGZvciB2aWRlbywgNDhraHogZm9yXG4gICAqIG9wdXMgYXVkaW8pIGV2ZXJ5IHNlY29uZC4gRm9yIHZpZGVvIGl0IHJvbGxzIG92ZXIgcm91Z2hseSBldmVyeSAxMyBob3Vycy5cbiAgICogVGhlIHNlbmQgY291bnRlciB3aWxsIGFkdmFuY2UgYXQgdGhlIGZyYW1lIHJhdGUgKDMwZnBzIGZvciB2aWRlbywgNTBmcHMgZm9yIDIwbXMgb3B1cyBhdWRpbylcbiAgICogZXZlcnkgc2Vjb25kLiBJdCB3aWxsIHRha2UgYSBsb25nIHRpbWUgdG8gcm9sbCBvdmVyLlxuICAgKlxuICAgKiBTZWUgYWxzbyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQWVzR2NtUGFyYW1zXG4gICAqL1xuICBwcml2YXRlIG1ha2VJVihzeW5jaHJvbml6YXRpb25Tb3VyY2U6IG51bWJlciwgdGltZXN0YW1wOiBudW1iZXIpIHtcbiAgICBjb25zdCBpdiA9IG5ldyBBcnJheUJ1ZmZlcihJVl9MRU5HVEgpO1xuICAgIGNvbnN0IGl2VmlldyA9IG5ldyBEYXRhVmlldyhpdik7XG5cbiAgICAvLyBoYXZpbmcgdG8ga2VlcCBvdXIgb3duIHNlbmQgY291bnQgKHNpbWlsYXIgdG8gYSBwaWN0dXJlIGlkKSBpcyBub3QgaWRlYWwuXG4gICAgaWYgKCF0aGlzLnNlbmRDb3VudHMuaGFzKHN5bmNocm9uaXphdGlvblNvdXJjZSkpIHtcbiAgICAgIC8vIEluaXRpYWxpemUgd2l0aCBhIHJhbmRvbSBvZmZzZXQsIHNpbWlsYXIgdG8gdGhlIFJUUCBzZXF1ZW5jZSBudW1iZXIuXG4gICAgICB0aGlzLnNlbmRDb3VudHMuc2V0KHN5bmNocm9uaXphdGlvblNvdXJjZSwgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMHhmZmZmKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VuZENvdW50ID0gdGhpcy5zZW5kQ291bnRzLmdldChzeW5jaHJvbml6YXRpb25Tb3VyY2UpID8/IDA7XG5cbiAgICBpdlZpZXcuc2V0VWludDMyKDAsIHN5bmNocm9uaXphdGlvblNvdXJjZSk7XG4gICAgaXZWaWV3LnNldFVpbnQzMig0LCB0aW1lc3RhbXApO1xuICAgIGl2Vmlldy5zZXRVaW50MzIoOCwgdGltZXN0YW1wIC0gKHNlbmRDb3VudCAlIDB4ZmZmZikpO1xuXG4gICAgdGhpcy5zZW5kQ291bnRzLnNldChzeW5jaHJvbml6YXRpb25Tb3VyY2UsIHNlbmRDb3VudCArIDEpO1xuXG4gICAgcmV0dXJuIGl2O1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRVbmVuY3J5cHRlZEJ5dGVzKGZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSB8IFJUQ0VuY29kZWRBdWRpb0ZyYW1lKTogbnVtYmVyIHtcbiAgICBpZiAoaXNWaWRlb0ZyYW1lKGZyYW1lKSkge1xuICAgICAgbGV0IGRldGVjdGVkQ29kZWMgPSB0aGlzLmdldFZpZGVvQ29kZWMoZnJhbWUpID8/IHRoaXMudmlkZW9Db2RlYztcblxuICAgICAgaWYgKGRldGVjdGVkQ29kZWMgPT09ICdhdjEnIHx8IGRldGVjdGVkQ29kZWMgPT09ICd2cDknKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtkZXRlY3RlZENvZGVjfSBpcyBub3QgeWV0IHN1cHBvcnRlZCBmb3IgZW5kIHRvIGVuZCBlbmNyeXB0aW9uYCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChkZXRlY3RlZENvZGVjID09PSAndnA4Jykge1xuICAgICAgICByZXR1cm4gVU5FTkNSWVBURURfQllURVNbZnJhbWUudHlwZV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShmcmFtZS5kYXRhKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG5hbHVJbmRpY2VzID0gZmluZE5BTFVJbmRpY2VzKGRhdGEpO1xuXG4gICAgICAgIC8vIGlmIHRoZSBkZXRlY3RlZCBjb2RlYyBpcyB1bmRlZmluZWQgd2UgdGVzdCB3aGV0aGVyIGl0IF9sb29rc18gbGlrZSBhIGgyNjQgZnJhbWUgYXMgYSBiZXN0IGd1ZXNzXG4gICAgICAgIGNvbnN0IGlzSDI2NCA9XG4gICAgICAgICAgZGV0ZWN0ZWRDb2RlYyA9PT0gJ2gyNjQnIHx8XG4gICAgICAgICAgbmFsdUluZGljZXMuc29tZSgobmFsdUluZGV4KSA9PlxuICAgICAgICAgICAgW05BTFVUeXBlLlNMSUNFX0lEUiwgTkFMVVR5cGUuU0xJQ0VfTk9OX0lEUl0uaW5jbHVkZXMocGFyc2VOQUxVVHlwZShkYXRhW25hbHVJbmRleF0pKSxcbiAgICAgICAgICApO1xuXG4gICAgICAgIGlmIChpc0gyNjQpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIG5hbHVJbmRpY2VzKSB7XG4gICAgICAgICAgICBsZXQgdHlwZSA9IHBhcnNlTkFMVVR5cGUoZGF0YVtpbmRleF0pO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgIGNhc2UgTkFMVVR5cGUuU0xJQ0VfSURSOlxuICAgICAgICAgICAgICBjYXNlIE5BTFVUeXBlLlNMSUNFX05PTl9JRFI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4ICsgMjtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ291bGQgbm90IGZpbmQgTkFMVScpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIG5vIG9wLCB3ZSBqdXN0IGNvbnRpbnVlIGFuZCBmYWxsYmFjayB0byB2cDhcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFVORU5DUllQVEVEX0JZVEVTW2ZyYW1lLnR5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gVU5FTkNSWVBURURfQllURVMuYXVkaW87XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGluc3BlY3RzIGZyYW1lIHBheWxvYWR0eXBlIGlmIGF2YWlsYWJsZSBhbmQgbWFwcyBpdCB0byB0aGUgY29kZWMgc3BlY2lmaWVkIGluIHJ0cE1hcFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRWaWRlb0NvZGVjKGZyYW1lOiBSVENFbmNvZGVkVmlkZW9GcmFtZSk6IFZpZGVvQ29kZWMgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLnJ0cE1hcC5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHBheWxvYWRUeXBlIGlzIG5vdCB5ZXQgcGFydCBvZiB0aGUgdHlwZXNjcmlwdCBkZWZpbml0aW9uIGFuZCBjdXJyZW50bHkgbm90IHN1cHBvcnRlZCBpbiBTYWZhcmlcbiAgICBjb25zdCBwYXlsb2FkVHlwZSA9IGZyYW1lLmdldE1ldGFkYXRhKCkucGF5bG9hZFR5cGU7XG4gICAgY29uc3QgY29kZWMgPSBwYXlsb2FkVHlwZSA/IHRoaXMucnRwTWFwLmdldChwYXlsb2FkVHlwZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIGNvZGVjO1xuICB9XG59XG5cbi8qKlxuICogU2xpY2UgdGhlIE5BTFVzIHByZXNlbnQgaW4gdGhlIHN1cHBsaWVkIGJ1ZmZlciwgYXNzdW1pbmcgaXQgaXMgYWxyZWFkeSBieXRlLWFsaWduZWRcbiAqIGNvZGUgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9tZWRvb3plL2gyNjQtZnJhbWUtcGFyc2VyL2Jsb2IvbWFpbi9saWIvTmFsVW5pdHMudHMgdG8gcmV0dXJuIGluZGljZXMgb25seVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZE5BTFVJbmRpY2VzKHN0cmVhbTogVWludDhBcnJheSk6IG51bWJlcltdIHtcbiAgY29uc3QgcmVzdWx0OiBudW1iZXJbXSA9IFtdO1xuICBsZXQgc3RhcnQgPSAwLFxuICAgIHBvcyA9IDAsXG4gICAgc2VhcmNoTGVuZ3RoID0gc3RyZWFtLmxlbmd0aCAtIDI7XG4gIHdoaWxlIChwb3MgPCBzZWFyY2hMZW5ndGgpIHtcbiAgICAvLyBza2lwIHVudGlsIGVuZCBvZiBjdXJyZW50IE5BTFVcbiAgICB3aGlsZSAoXG4gICAgICBwb3MgPCBzZWFyY2hMZW5ndGggJiZcbiAgICAgICEoc3RyZWFtW3Bvc10gPT09IDAgJiYgc3RyZWFtW3BvcyArIDFdID09PSAwICYmIHN0cmVhbVtwb3MgKyAyXSA9PT0gMSlcbiAgICApXG4gICAgICBwb3MrKztcbiAgICBpZiAocG9zID49IHNlYXJjaExlbmd0aCkgcG9zID0gc3RyZWFtLmxlbmd0aDtcbiAgICAvLyByZW1vdmUgdHJhaWxpbmcgemVyb3MgZnJvbSBjdXJyZW50IE5BTFVcbiAgICBsZXQgZW5kID0gcG9zO1xuICAgIHdoaWxlIChlbmQgPiBzdGFydCAmJiBzdHJlYW1bZW5kIC0gMV0gPT09IDApIGVuZC0tO1xuICAgIC8vIHNhdmUgY3VycmVudCBOQUxVXG4gICAgaWYgKHN0YXJ0ID09PSAwKSB7XG4gICAgICBpZiAoZW5kICE9PSBzdGFydCkgdGhyb3cgVHlwZUVycm9yKCdieXRlIHN0cmVhbSBjb250YWlucyBsZWFkaW5nIGRhdGEnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnB1c2goc3RhcnQpO1xuICAgIH1cbiAgICAvLyBiZWdpbiBuZXcgTkFMVVxuICAgIHN0YXJ0ID0gcG9zID0gcG9zICsgMztcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VOQUxVVHlwZShzdGFydEJ5dGU6IG51bWJlcik6IE5BTFVUeXBlIHtcbiAgcmV0dXJuIHN0YXJ0Qnl0ZSAmIGtOYWx1VHlwZU1hc2s7XG59XG5cbmNvbnN0IGtOYWx1VHlwZU1hc2sgPSAweDFmO1xuXG5leHBvcnQgZW51bSBOQUxVVHlwZSB7XG4gIC8qKiBDb2RlZCBzbGljZSBvZiBhIG5vbi1JRFIgcGljdHVyZSAqL1xuICBTTElDRV9OT05fSURSID0gMSxcbiAgLyoqIENvZGVkIHNsaWNlIGRhdGEgcGFydGl0aW9uIEEgKi9cbiAgU0xJQ0VfUEFSVElUSU9OX0EgPSAyLFxuICAvKiogQ29kZWQgc2xpY2UgZGF0YSBwYXJ0aXRpb24gQiAqL1xuICBTTElDRV9QQVJUSVRJT05fQiA9IDMsXG4gIC8qKiBDb2RlZCBzbGljZSBkYXRhIHBhcnRpdGlvbiBDICovXG4gIFNMSUNFX1BBUlRJVElPTl9DID0gNCxcbiAgLyoqIENvZGVkIHNsaWNlIG9mIGFuIElEUiBwaWN0dXJlICovXG4gIFNMSUNFX0lEUiA9IDUsXG4gIC8qKiBTdXBwbGVtZW50YWwgZW5oYW5jZW1lbnQgaW5mb3JtYXRpb24gKi9cbiAgU0VJID0gNixcbiAgLyoqIFNlcXVlbmNlIHBhcmFtZXRlciBzZXQgKi9cbiAgU1BTID0gNyxcbiAgLyoqIFBpY3R1cmUgcGFyYW1ldGVyIHNldCAqL1xuICBQUFMgPSA4LFxuICAvKiogQWNjZXNzIHVuaXQgZGVsaW1pdGVyICovXG4gIEFVRCA9IDksXG4gIC8qKiBFbmQgb2Ygc2VxdWVuY2UgKi9cbiAgRU5EX1NFUSA9IDEwLFxuICAvKiogRW5kIG9mIHN0cmVhbSAqL1xuICBFTkRfU1RSRUFNID0gMTEsXG4gIC8qKiBGaWxsZXIgZGF0YSAqL1xuICBGSUxMRVJfREFUQSA9IDEyLFxuICAvKiogU2VxdWVuY2UgcGFyYW1ldGVyIHNldCBleHRlbnNpb24gKi9cbiAgU1BTX0VYVCA9IDEzLFxuICAvKiogUHJlZml4IE5BTCB1bml0ICovXG4gIFBSRUZJWF9OQUxVID0gMTQsXG4gIC8qKiBTdWJzZXQgc2VxdWVuY2UgcGFyYW1ldGVyIHNldCAqL1xuICBTVUJTRVRfU1BTID0gMTUsXG4gIC8qKiBEZXB0aCBwYXJhbWV0ZXIgc2V0ICovXG4gIERQUyA9IDE2LFxuXG4gIC8vIDE3LCAxOCByZXNlcnZlZFxuXG4gIC8qKiBDb2RlZCBzbGljZSBvZiBhbiBhdXhpbGlhcnkgY29kZWQgcGljdHVyZSB3aXRob3V0IHBhcnRpdGlvbmluZyAqL1xuICBTTElDRV9BVVggPSAxOSxcbiAgLyoqIENvZGVkIHNsaWNlIGV4dGVuc2lvbiAqL1xuICBTTElDRV9FWFQgPSAyMCxcbiAgLyoqIENvZGVkIHNsaWNlIGV4dGVuc2lvbiBmb3IgYSBkZXB0aCB2aWV3IGNvbXBvbmVudCBvciBhIDNELUFWQyB0ZXh0dXJlIHZpZXcgY29tcG9uZW50ICovXG4gIFNMSUNFX0xBWUVSX0VYVCA9IDIxLFxuXG4gIC8vIDIyLCAyMyByZXNlcnZlZFxufVxuXG4vKipcbiAqIHdlIHVzZSBhIG1hZ2ljIGZyYW1lIHRyYWlsZXIgdG8gZGV0ZWN0IHdoZXRoZXIgYSBmcmFtZSBpcyBpbmplY3RlZFxuICogYnkgdGhlIGxpdmVraXQgc2VydmVyIGFuZCB0aHVzIHRvIGJlIHRyZWF0ZWQgYXMgdW5lbmNyeXB0ZWRcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNGcmFtZVNlcnZlckluamVjdGVkKGZyYW1lRGF0YTogQXJyYXlCdWZmZXIsIHRyYWlsZXJCeXRlczogVWludDhBcnJheSk6IGJvb2xlYW4ge1xuICBpZiAodHJhaWxlckJ5dGVzLmJ5dGVMZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgZnJhbWVUcmFpbGVyID0gbmV3IFVpbnQ4QXJyYXkoXG4gICAgZnJhbWVEYXRhLnNsaWNlKGZyYW1lRGF0YS5ieXRlTGVuZ3RoIC0gdHJhaWxlckJ5dGVzLmJ5dGVMZW5ndGgpLFxuICApO1xuICByZXR1cm4gdHJhaWxlckJ5dGVzLmV2ZXJ5KCh2YWx1ZSwgaW5kZXgpID0+IHZhbHVlID09PSBmcmFtZVRyYWlsZXJbaW5kZXhdKTtcbn1cbiIsImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50cyc7XG5pbXBvcnQgdHlwZSBUeXBlZEV2ZW50RW1pdHRlciBmcm9tICd0eXBlZC1lbWl0dGVyJztcbmltcG9ydCB7IHdvcmtlckxvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBLRVlSSU5HX1NJWkUgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgS2V5SGFuZGxlckV2ZW50LCB0eXBlIFBhcnRpY2lwYW50S2V5SGFuZGxlckNhbGxiYWNrcyB9IGZyb20gJy4uL2V2ZW50cyc7XG5pbXBvcnQgdHlwZSB7IEtleVByb3ZpZGVyT3B0aW9ucywgS2V5U2V0IH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHsgZGVyaXZlS2V5cywgaW1wb3J0S2V5LCByYXRjaGV0IH0gZnJvbSAnLi4vdXRpbHMnO1xuXG4vLyBUT0RPIFBhcnRpY2lwYW50S2V5SGFuZGxlcnMgY3VycmVudGx5IGRvbid0IGdldCBkZXN0cm95ZWQgb24gcGFydGljaXBhbnQgZGlzY29ubmVjdFxuLy8gd2UgY291bGQgZG8gdGhpcyBieSBoYXZpbmcgYSBzZXBhcmF0ZSB3b3JrZXIgbWVzc2FnZSBvbiBwYXJ0aWNpcGFudCBkaXNjb25uZWN0ZWQuXG5cbi8qKlxuICogUGFydGljaXBhbnRLZXlIYW5kbGVyIGlzIHJlc3BvbnNpYmxlIGZvciBwcm92aWRpbmcgYSBjcnlwdG9yIGluc3RhbmNlIHdpdGggdGhlXG4gKiBlbi0vZGVjcnlwdGlvbiBrZXkgb2YgYSBwYXJ0aWNpcGFudC4gSXQgYXNzdW1lcyB0aGF0IGFsbCB0cmFja3Mgb2YgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudFxuICogYXJlIGVuY3J5cHRlZCB3aXRoIHRoZSBzYW1lIGtleS5cbiAqIEFkZGl0aW9uYWxseSBpdCBleHBvc2VzIGEgbWV0aG9kIHRvIHJhdGNoZXQgYSBrZXkgd2hpY2ggY2FuIGJlIHVzZWQgYnkgdGhlIGNyeXB0b3IgZWl0aGVyIGF1dG9tYXRpY2FsbHlcbiAqIGlmIGRlY3J5cHRpb24gZmFpbHMgb3IgY2FuIGJlIHRyaWdnZXJlZCBtYW51YWxseSBvbiBib3RoIHNlbmRlciBhbmQgcmVjZWl2ZXIgc2lkZS5cbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBQYXJ0aWNpcGFudEtleUhhbmRsZXIgZXh0ZW5kcyAoRXZlbnRFbWl0dGVyIGFzIG5ldyAoKSA9PiBUeXBlZEV2ZW50RW1pdHRlcjxQYXJ0aWNpcGFudEtleUhhbmRsZXJDYWxsYmFja3M+KSB7XG4gIHByaXZhdGUgY3VycmVudEtleUluZGV4OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBjcnlwdG9LZXlSaW5nOiBBcnJheTxLZXlTZXQgfCB1bmRlZmluZWQ+O1xuXG4gIHByaXZhdGUga2V5UHJvdmlkZXJPcHRpb25zOiBLZXlQcm92aWRlck9wdGlvbnM7XG5cbiAgcHJpdmF0ZSByYXRjaGV0UHJvbWlzZU1hcDogTWFwPG51bWJlciwgUHJvbWlzZTxDcnlwdG9LZXk+PjtcblxuICBwcml2YXRlIHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZztcblxuICBwcml2YXRlIGRlY3J5cHRpb25GYWlsdXJlQ291bnQgPSAwO1xuXG4gIHByaXZhdGUgX2hhc1ZhbGlkS2V5OiBib29sZWFuID0gdHJ1ZTtcblxuICBnZXQgaGFzVmFsaWRLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hhc1ZhbGlkS2V5O1xuICB9XG5cbiAgY29uc3RydWN0b3IocGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nLCBrZXlQcm92aWRlck9wdGlvbnM6IEtleVByb3ZpZGVyT3B0aW9ucykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jdXJyZW50S2V5SW5kZXggPSAwO1xuICAgIHRoaXMuY3J5cHRvS2V5UmluZyA9IG5ldyBBcnJheShLRVlSSU5HX1NJWkUpLmZpbGwodW5kZWZpbmVkKTtcbiAgICB0aGlzLmtleVByb3ZpZGVyT3B0aW9ucyA9IGtleVByb3ZpZGVyT3B0aW9ucztcbiAgICB0aGlzLnJhdGNoZXRQcm9taXNlTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSA9IHBhcnRpY2lwYW50SWRlbnRpdHk7XG4gICAgdGhpcy5yZXNldEtleVN0YXR1cygpO1xuICB9XG5cbiAgZGVjcnlwdGlvbkZhaWx1cmUoKSB7XG4gICAgaWYgKHRoaXMua2V5UHJvdmlkZXJPcHRpb25zLmZhaWx1cmVUb2xlcmFuY2UgPCAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudCArPSAxO1xuXG4gICAgaWYgKHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudCA+IHRoaXMua2V5UHJvdmlkZXJPcHRpb25zLmZhaWx1cmVUb2xlcmFuY2UpIHtcbiAgICAgIHdvcmtlckxvZ2dlci53YXJuKGBrZXkgZm9yICR7dGhpcy5wYXJ0aWNpcGFudElkZW50aXR5fSBpcyBiZWluZyBtYXJrZWQgYXMgaW52YWxpZGApO1xuICAgICAgdGhpcy5faGFzVmFsaWRLZXkgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkZWNyeXB0aW9uU3VjY2VzcygpIHtcbiAgICB0aGlzLnJlc2V0S2V5U3RhdHVzKCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIGFmdGVyIHVzZXIgaW5pdGlhdGVkIHJhdGNoZXQgb3IgYSBuZXcga2V5IGhhcyBiZWVuIHNldCBpbiBvcmRlciB0byBtYWtlIHN1cmUgdG8gbWFyayBwb3RlbnRpYWxseVxuICAgKiBpbnZhbGlkIGtleXMgYXMgdmFsaWQgYWdhaW5cbiAgICovXG4gIHJlc2V0S2V5U3RhdHVzKCkge1xuICAgIHRoaXMuZGVjcnlwdGlvbkZhaWx1cmVDb3VudCA9IDA7XG4gICAgdGhpcy5faGFzVmFsaWRLZXkgPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJhdGNoZXRzIHRoZSBjdXJyZW50IGtleSAob3IgdGhlIG9uZSBhdCBrZXlJbmRleCBpZiBwcm92aWRlZCkgYW5kXG4gICAqIHJldHVybnMgdGhlIHJhdGNoZXRlZCBtYXRlcmlhbFxuICAgKiBpZiBgc2V0S2V5YCBpcyB0cnVlIChkZWZhdWx0KSwgaXQgd2lsbCBhbHNvIHNldCB0aGUgcmF0Y2hldGVkIGtleSBkaXJlY3RseSBvbiB0aGUgY3J5cHRvIGtleSByaW5nXG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKiBAcGFyYW0gc2V0S2V5XG4gICAqL1xuICByYXRjaGV0S2V5KGtleUluZGV4PzogbnVtYmVyLCBzZXRLZXkgPSB0cnVlKTogUHJvbWlzZTxDcnlwdG9LZXk+IHtcbiAgICBjb25zdCBjdXJyZW50S2V5SW5kZXggPSBrZXlJbmRleCA/PyB0aGlzLmdldEN1cnJlbnRLZXlJbmRleCgpO1xuXG4gICAgY29uc3QgZXhpc3RpbmdQcm9taXNlID0gdGhpcy5yYXRjaGV0UHJvbWlzZU1hcC5nZXQoY3VycmVudEtleUluZGV4KTtcbiAgICBpZiAodHlwZW9mIGV4aXN0aW5nUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBleGlzdGluZ1Byb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHJhdGNoZXRQcm9taXNlID0gbmV3IFByb21pc2U8Q3J5cHRvS2V5Pihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBrZXlTZXQgPSB0aGlzLmdldEtleVNldChjdXJyZW50S2V5SW5kZXgpO1xuICAgICAgICBpZiAoIWtleVNldCkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IHJhdGNoZXQga2V5IHdpdGhvdXQgYSB2YWxpZCBrZXlzZXQgb2YgcGFydGljaXBhbnQgJHt0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHl9YCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJlbnRNYXRlcmlhbCA9IGtleVNldC5tYXRlcmlhbDtcbiAgICAgICAgY29uc3QgbmV3TWF0ZXJpYWwgPSBhd2FpdCBpbXBvcnRLZXkoXG4gICAgICAgICAgYXdhaXQgcmF0Y2hldChjdXJyZW50TWF0ZXJpYWwsIHRoaXMua2V5UHJvdmlkZXJPcHRpb25zLnJhdGNoZXRTYWx0KSxcbiAgICAgICAgICBjdXJyZW50TWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsXG4gICAgICAgICAgJ2Rlcml2ZScsXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHNldEtleSkge1xuICAgICAgICAgIHRoaXMuc2V0S2V5RnJvbU1hdGVyaWFsKG5ld01hdGVyaWFsLCBjdXJyZW50S2V5SW5kZXgsIHRydWUpO1xuICAgICAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgICAgIEtleUhhbmRsZXJFdmVudC5LZXlSYXRjaGV0ZWQsXG4gICAgICAgICAgICBuZXdNYXRlcmlhbCxcbiAgICAgICAgICAgIHRoaXMucGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICAgIGN1cnJlbnRLZXlJbmRleCxcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUobmV3TWF0ZXJpYWwpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZWplY3QoZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnJhdGNoZXRQcm9taXNlTWFwLmRlbGV0ZShjdXJyZW50S2V5SW5kZXgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMucmF0Y2hldFByb21pc2VNYXAuc2V0KGN1cnJlbnRLZXlJbmRleCwgcmF0Y2hldFByb21pc2UpO1xuICAgIHJldHVybiByYXRjaGV0UHJvbWlzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0YWtlcyBpbiBhIGtleSBtYXRlcmlhbCB3aXRoIGBkZXJpdmVCaXRzYCBhbmQgYGRlcml2ZUtleWAgc2V0IGFzIGtleSB1c2FnZXNcbiAgICogYW5kIGRlcml2ZXMgZW5jcnlwdGlvbiBrZXlzIGZyb20gdGhlIG1hdGVyaWFsIGFuZCBzZXRzIGl0IG9uIHRoZSBrZXkgcmluZyBidWZmZXJcbiAgICogdG9nZXRoZXIgd2l0aCB0aGUgbWF0ZXJpYWxcbiAgICogYWxzbyByZXNldHMgdGhlIHZhbGlkIGtleSBwcm9wZXJ0eSBhbmQgdXBkYXRlcyB0aGUgY3VycmVudEtleUluZGV4XG4gICAqL1xuICBhc3luYyBzZXRLZXkobWF0ZXJpYWw6IENyeXB0b0tleSwga2V5SW5kZXggPSAwKSB7XG4gICAgYXdhaXQgdGhpcy5zZXRLZXlGcm9tTWF0ZXJpYWwobWF0ZXJpYWwsIGtleUluZGV4KTtcbiAgICB0aGlzLnJlc2V0S2V5U3RhdHVzKCk7XG4gIH1cblxuICAvKipcbiAgICogdGFrZXMgaW4gYSBrZXkgbWF0ZXJpYWwgd2l0aCBgZGVyaXZlQml0c2AgYW5kIGBkZXJpdmVLZXlgIHNldCBhcyBrZXkgdXNhZ2VzXG4gICAqIGFuZCBkZXJpdmVzIGVuY3J5cHRpb24ga2V5cyBmcm9tIHRoZSBtYXRlcmlhbCBhbmQgc2V0cyBpdCBvbiB0aGUga2V5IHJpbmcgYnVmZmVyXG4gICAqIHRvZ2V0aGVyIHdpdGggdGhlIG1hdGVyaWFsXG4gICAqIGFsc28gdXBkYXRlcyB0aGUgY3VycmVudEtleUluZGV4XG4gICAqL1xuICBhc3luYyBzZXRLZXlGcm9tTWF0ZXJpYWwobWF0ZXJpYWw6IENyeXB0b0tleSwga2V5SW5kZXggPSAwLCBlbWl0UmF0Y2hldEV2ZW50ID0gZmFsc2UpIHtcbiAgICB3b3JrZXJMb2dnZXIuZGVidWcoJ3NldHRpbmcgbmV3IGtleScpO1xuICAgIGlmIChrZXlJbmRleCA+PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnRLZXlJbmRleCA9IGtleUluZGV4ICUgdGhpcy5jcnlwdG9LZXlSaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3Qga2V5U2V0ID0gYXdhaXQgZGVyaXZlS2V5cyhtYXRlcmlhbCwgdGhpcy5rZXlQcm92aWRlck9wdGlvbnMucmF0Y2hldFNhbHQpO1xuICAgIHRoaXMuc2V0S2V5U2V0KGtleVNldCwgdGhpcy5jdXJyZW50S2V5SW5kZXgsIGVtaXRSYXRjaGV0RXZlbnQpO1xuICB9XG5cbiAgc2V0S2V5U2V0KGtleVNldDogS2V5U2V0LCBrZXlJbmRleDogbnVtYmVyLCBlbWl0UmF0Y2hldEV2ZW50ID0gZmFsc2UpIHtcbiAgICB0aGlzLmNyeXB0b0tleVJpbmdba2V5SW5kZXggJSB0aGlzLmNyeXB0b0tleVJpbmcubGVuZ3RoXSA9IGtleVNldDtcblxuICAgIGlmIChlbWl0UmF0Y2hldEV2ZW50KSB7XG4gICAgICB0aGlzLmVtaXQoS2V5SGFuZGxlckV2ZW50LktleVJhdGNoZXRlZCwga2V5U2V0Lm1hdGVyaWFsLCB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBzZXRDdXJyZW50S2V5SW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgIHRoaXMuY3VycmVudEtleUluZGV4ID0gaW5kZXggJSB0aGlzLmNyeXB0b0tleVJpbmcubGVuZ3RoO1xuICAgIHRoaXMucmVzZXRLZXlTdGF0dXMoKTtcbiAgfVxuXG4gIGdldEN1cnJlbnRLZXlJbmRleCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50S2V5SW5kZXg7XG4gIH1cblxuICAvKipcbiAgICogcmV0dXJucyBjdXJyZW50bHkgdXNlZCBLZXlTZXQgb3IgdGhlIG9uZSBhdCBga2V5SW5kZXhgIGlmIHByb3ZpZGVkXG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgZ2V0S2V5U2V0KGtleUluZGV4PzogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY3J5cHRvS2V5UmluZ1trZXlJbmRleCA/PyB0aGlzLmN1cnJlbnRLZXlJbmRleF07XG4gIH1cbn1cbiIsImltcG9ydCB7IHdvcmtlckxvZ2dlciB9IGZyb20gJy4uLy4uL2xvZ2dlcic7XG5pbXBvcnQgeyBLRVlfUFJPVklERVJfREVGQVVMVFMgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQ3J5cHRvckVycm9yUmVhc29uIH0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7IENyeXB0b3JFdmVudCwgS2V5SGFuZGxlckV2ZW50IH0gZnJvbSAnLi4vZXZlbnRzJztcbmltcG9ydCB0eXBlIHtcbiAgRTJFRVdvcmtlck1lc3NhZ2UsXG4gIEVycm9yTWVzc2FnZSxcbiAgSW5pdEFjayxcbiAgS2V5UHJvdmlkZXJPcHRpb25zLFxuICBSYXRjaGV0TWVzc2FnZSxcbiAgUmF0Y2hldFJlcXVlc3RNZXNzYWdlLFxufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgeyBGcmFtZUNyeXB0b3IsIGVuY3J5cHRpb25FbmFibGVkTWFwIH0gZnJvbSAnLi9GcmFtZUNyeXB0b3InO1xuaW1wb3J0IHsgUGFydGljaXBhbnRLZXlIYW5kbGVyIH0gZnJvbSAnLi9QYXJ0aWNpcGFudEtleUhhbmRsZXInO1xuXG5jb25zdCBwYXJ0aWNpcGFudENyeXB0b3JzOiBGcmFtZUNyeXB0b3JbXSA9IFtdO1xuY29uc3QgcGFydGljaXBhbnRLZXlzOiBNYXA8c3RyaW5nLCBQYXJ0aWNpcGFudEtleUhhbmRsZXI+ID0gbmV3IE1hcCgpO1xubGV0IHNoYXJlZEtleUhhbmRsZXI6IFBhcnRpY2lwYW50S2V5SGFuZGxlciB8IHVuZGVmaW5lZDtcblxubGV0IGlzRW5jcnlwdGlvbkVuYWJsZWQ6IGJvb2xlYW4gPSBmYWxzZTtcblxubGV0IHVzZVNoYXJlZEtleTogYm9vbGVhbiA9IGZhbHNlO1xuXG5sZXQgc2hhcmVkS2V5OiBDcnlwdG9LZXkgfCB1bmRlZmluZWQ7XG5cbmxldCBzaWZUcmFpbGVyOiBVaW50OEFycmF5IHwgdW5kZWZpbmVkO1xuXG5sZXQga2V5UHJvdmlkZXJPcHRpb25zOiBLZXlQcm92aWRlck9wdGlvbnMgPSBLRVlfUFJPVklERVJfREVGQVVMVFM7XG5cbndvcmtlckxvZ2dlci5zZXREZWZhdWx0TGV2ZWwoJ2luZm8nKTtcblxub25tZXNzYWdlID0gKGV2KSA9PiB7XG4gIGNvbnN0IHsga2luZCwgZGF0YSB9OiBFMkVFV29ya2VyTWVzc2FnZSA9IGV2LmRhdGE7XG5cbiAgc3dpdGNoIChraW5kKSB7XG4gICAgY2FzZSAnaW5pdCc6XG4gICAgICB3b3JrZXJMb2dnZXIuaW5mbygnd29ya2VyIGluaXRpYWxpemVkJyk7XG4gICAgICBrZXlQcm92aWRlck9wdGlvbnMgPSBkYXRhLmtleVByb3ZpZGVyT3B0aW9ucztcbiAgICAgIHVzZVNoYXJlZEtleSA9ICEhZGF0YS5rZXlQcm92aWRlck9wdGlvbnMuc2hhcmVkS2V5O1xuICAgICAgLy8gYWNrbm93bGVkZ2UgaW5pdCBzdWNjZXNzZnVsXG4gICAgICBjb25zdCBhY2tNc2c6IEluaXRBY2sgPSB7XG4gICAgICAgIGtpbmQ6ICdpbml0QWNrJyxcbiAgICAgICAgZGF0YTogeyBlbmFibGVkOiBpc0VuY3J5cHRpb25FbmFibGVkIH0sXG4gICAgICB9O1xuICAgICAgcG9zdE1lc3NhZ2UoYWNrTXNnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICBzZXRFbmNyeXB0aW9uRW5hYmxlZChkYXRhLmVuYWJsZWQsIGRhdGEucGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgICB3b3JrZXJMb2dnZXIuaW5mbygndXBkYXRlZCBlMmVlIGVuYWJsZWQgc3RhdHVzJyk7XG4gICAgICAvLyBhY2tub3dsZWRnZSBlbmFibGUgY2FsbCBzdWNjZXNzZnVsXG4gICAgICBwb3N0TWVzc2FnZShldi5kYXRhKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RlY29kZSc6XG4gICAgICBsZXQgY3J5cHRvciA9IGdldFRyYWNrQ3J5cHRvcihkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHksIGRhdGEudHJhY2tJZCk7XG4gICAgICBjcnlwdG9yLnNldHVwVHJhbnNmb3JtKFxuICAgICAgICBraW5kLFxuICAgICAgICBkYXRhLnJlYWRhYmxlU3RyZWFtLFxuICAgICAgICBkYXRhLndyaXRhYmxlU3RyZWFtLFxuICAgICAgICBkYXRhLnRyYWNrSWQsXG4gICAgICAgIGRhdGEuY29kZWMsXG4gICAgICApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZW5jb2RlJzpcbiAgICAgIGxldCBwdWJDcnlwdG9yID0gZ2V0VHJhY2tDcnlwdG9yKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSwgZGF0YS50cmFja0lkKTtcbiAgICAgIHB1YkNyeXB0b3Iuc2V0dXBUcmFuc2Zvcm0oXG4gICAgICAgIGtpbmQsXG4gICAgICAgIGRhdGEucmVhZGFibGVTdHJlYW0sXG4gICAgICAgIGRhdGEud3JpdGFibGVTdHJlYW0sXG4gICAgICAgIGRhdGEudHJhY2tJZCxcbiAgICAgICAgZGF0YS5jb2RlYyxcbiAgICAgICk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZXRLZXknOlxuICAgICAgaWYgKHVzZVNoYXJlZEtleSkge1xuICAgICAgICB3b3JrZXJMb2dnZXIud2Fybignc2V0IHNoYXJlZCBrZXknKTtcbiAgICAgICAgc2V0U2hhcmVkS2V5KGRhdGEua2V5LCBkYXRhLmtleUluZGV4KTtcbiAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgIHdvcmtlckxvZ2dlci53YXJuKGBzZXQgcGFydGljaXBhbnQgc2VuZGVyIGtleSAke2RhdGEucGFydGljaXBhbnRJZGVudGl0eX1gKTtcbiAgICAgICAgZ2V0UGFydGljaXBhbnRLZXlIYW5kbGVyKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkuc2V0S2V5KGRhdGEua2V5LCBkYXRhLmtleUluZGV4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtlckxvZ2dlci5lcnJvcignbm8gcGFydGljaXBhbnQgSWQgd2FzIHByb3ZpZGVkIGFuZCBzaGFyZWQga2V5IHVzYWdlIGlzIGRpc2FibGVkJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyZW1vdmVUcmFuc2Zvcm0nOlxuICAgICAgdW5zZXRDcnlwdG9yUGFydGljaXBhbnQoZGF0YS50cmFja0lkKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3VwZGF0ZUNvZGVjJzpcbiAgICAgIGdldFRyYWNrQ3J5cHRvcihkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHksIGRhdGEudHJhY2tJZCkuc2V0VmlkZW9Db2RlYyhkYXRhLmNvZGVjKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NldFJUUE1hcCc6XG4gICAgICAvLyB0aGlzIGlzIG9ubHkgdXNlZCBmb3IgdGhlIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgICBwYXJ0aWNpcGFudENyeXB0b3JzLmZvckVhY2goKGNyKSA9PiB7XG4gICAgICAgIGlmIChjci5nZXRQYXJ0aWNpcGFudElkZW50aXR5KCkgPT09IGRhdGEucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgICAgICAgIGNyLnNldFJ0cE1hcChkYXRhLm1hcCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAncmF0Y2hldFJlcXVlc3QnOlxuICAgICAgaGFuZGxlUmF0Y2hldFJlcXVlc3QoZGF0YSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZXRTaWZUcmFpbGVyJzpcbiAgICAgIGhhbmRsZVNpZlRyYWlsZXIoZGF0YS50cmFpbGVyKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBicmVhaztcbiAgfVxufTtcblxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlUmF0Y2hldFJlcXVlc3QoZGF0YTogUmF0Y2hldFJlcXVlc3RNZXNzYWdlWydkYXRhJ10pIHtcbiAgaWYgKHVzZVNoYXJlZEtleSkge1xuICAgIGNvbnN0IGtleUhhbmRsZXIgPSBnZXRTaGFyZWRLZXlIYW5kbGVyKCk7XG4gICAgYXdhaXQga2V5SGFuZGxlci5yYXRjaGV0S2V5KGRhdGEua2V5SW5kZXgpO1xuICAgIGtleUhhbmRsZXIucmVzZXRLZXlTdGF0dXMoKTtcbiAgfSBlbHNlIGlmIChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBjb25zdCBrZXlIYW5kbGVyID0gZ2V0UGFydGljaXBhbnRLZXlIYW5kbGVyKGRhdGEucGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgYXdhaXQga2V5SGFuZGxlci5yYXRjaGV0S2V5KGRhdGEua2V5SW5kZXgpO1xuICAgIGtleUhhbmRsZXIucmVzZXRLZXlTdGF0dXMoKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrZXJMb2dnZXIuZXJyb3IoXG4gICAgICAnbm8gcGFydGljaXBhbnQgSWQgd2FzIHByb3ZpZGVkIGZvciByYXRjaGV0IHJlcXVlc3QgYW5kIHNoYXJlZCBrZXkgdXNhZ2UgaXMgZGlzYWJsZWQnLFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tDcnlwdG9yKHBhcnRpY2lwYW50SWRlbnRpdHk6IHN0cmluZywgdHJhY2tJZDogc3RyaW5nKSB7XG4gIGxldCBjcnlwdG9yID0gcGFydGljaXBhbnRDcnlwdG9ycy5maW5kKChjKSA9PiBjLmdldFRyYWNrSWQoKSA9PT0gdHJhY2tJZCk7XG4gIGlmICghY3J5cHRvcikge1xuICAgIHdvcmtlckxvZ2dlci5pbmZvKCdjcmVhdGluZyBuZXcgY3J5cHRvciBmb3InLCB7IHBhcnRpY2lwYW50SWRlbnRpdHkgfSk7XG4gICAgaWYgKCFrZXlQcm92aWRlck9wdGlvbnMpIHtcbiAgICAgIHRocm93IEVycm9yKCdNaXNzaW5nIGtleVByb3ZpZGVyIG9wdGlvbnMnKTtcbiAgICB9XG4gICAgY3J5cHRvciA9IG5ldyBGcmFtZUNyeXB0b3Ioe1xuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleXM6IGdldFBhcnRpY2lwYW50S2V5SGFuZGxlcihwYXJ0aWNpcGFudElkZW50aXR5KSxcbiAgICAgIGtleVByb3ZpZGVyT3B0aW9ucyxcbiAgICAgIHNpZlRyYWlsZXIsXG4gICAgfSk7XG5cbiAgICBzZXR1cENyeXB0b3JFcnJvckV2ZW50cyhjcnlwdG9yKTtcbiAgICBwYXJ0aWNpcGFudENyeXB0b3JzLnB1c2goY3J5cHRvcik7XG4gIH0gZWxzZSBpZiAocGFydGljaXBhbnRJZGVudGl0eSAhPT0gY3J5cHRvci5nZXRQYXJ0aWNpcGFudElkZW50aXR5KCkpIHtcbiAgICAvLyBhc3NpZ24gbmV3IHBhcnRpY2lwYW50IGlkIHRvIHRyYWNrIGNyeXB0b3IgYW5kIHBhc3MgaW4gY29ycmVjdCBrZXkgaGFuZGxlclxuICAgIGNyeXB0b3Iuc2V0UGFydGljaXBhbnQocGFydGljaXBhbnRJZGVudGl0eSwgZ2V0UGFydGljaXBhbnRLZXlIYW5kbGVyKHBhcnRpY2lwYW50SWRlbnRpdHkpKTtcbiAgfVxuICBpZiAoc2hhcmVkS2V5KSB7XG4gIH1cbiAgcmV0dXJuIGNyeXB0b3I7XG59XG5cbmZ1bmN0aW9uIGdldFBhcnRpY2lwYW50S2V5SGFuZGxlcihwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcpIHtcbiAgaWYgKHVzZVNoYXJlZEtleSkge1xuICAgIHJldHVybiBnZXRTaGFyZWRLZXlIYW5kbGVyKCk7XG4gIH1cbiAgbGV0IGtleXMgPSBwYXJ0aWNpcGFudEtleXMuZ2V0KHBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICBpZiAoIWtleXMpIHtcbiAgICBrZXlzID0gbmV3IFBhcnRpY2lwYW50S2V5SGFuZGxlcihwYXJ0aWNpcGFudElkZW50aXR5LCBrZXlQcm92aWRlck9wdGlvbnMpO1xuICAgIGlmIChzaGFyZWRLZXkpIHtcbiAgICAgIGtleXMuc2V0S2V5KHNoYXJlZEtleSk7XG4gICAgfVxuICAgIGtleXMub24oS2V5SGFuZGxlckV2ZW50LktleVJhdGNoZXRlZCwgZW1pdFJhdGNoZXRlZEtleXMpO1xuICAgIHBhcnRpY2lwYW50S2V5cy5zZXQocGFydGljaXBhbnRJZGVudGl0eSwga2V5cyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIGdldFNoYXJlZEtleUhhbmRsZXIoKSB7XG4gIGlmICghc2hhcmVkS2V5SGFuZGxlcikge1xuICAgIHNoYXJlZEtleUhhbmRsZXIgPSBuZXcgUGFydGljaXBhbnRLZXlIYW5kbGVyKCdzaGFyZWQta2V5Jywga2V5UHJvdmlkZXJPcHRpb25zKTtcbiAgfVxuICByZXR1cm4gc2hhcmVkS2V5SGFuZGxlcjtcbn1cblxuZnVuY3Rpb24gdW5zZXRDcnlwdG9yUGFydGljaXBhbnQodHJhY2tJZDogc3RyaW5nKSB7XG4gIHBhcnRpY2lwYW50Q3J5cHRvcnMuZmluZCgoYykgPT4gYy5nZXRUcmFja0lkKCkgPT09IHRyYWNrSWQpPy51bnNldFBhcnRpY2lwYW50KCk7XG59XG5cbmZ1bmN0aW9uIHNldEVuY3J5cHRpb25FbmFibGVkKGVuYWJsZTogYm9vbGVhbiwgcGFydGljaXBhbnRJZGVudGl0eTogc3RyaW5nKSB7XG4gIGVuY3J5cHRpb25FbmFibGVkTWFwLnNldChwYXJ0aWNpcGFudElkZW50aXR5LCBlbmFibGUpO1xufVxuXG5mdW5jdGlvbiBzZXRTaGFyZWRLZXkoa2V5OiBDcnlwdG9LZXksIGluZGV4PzogbnVtYmVyKSB7XG4gIHdvcmtlckxvZ2dlci5kZWJ1Zygnc2V0dGluZyBzaGFyZWQga2V5Jyk7XG4gIHNoYXJlZEtleSA9IGtleTtcbiAgZ2V0U2hhcmVkS2V5SGFuZGxlcigpLnNldEtleShrZXksIGluZGV4KTtcbn1cblxuZnVuY3Rpb24gc2V0dXBDcnlwdG9yRXJyb3JFdmVudHMoY3J5cHRvcjogRnJhbWVDcnlwdG9yKSB7XG4gIGNyeXB0b3Iub24oQ3J5cHRvckV2ZW50LkVycm9yLCAoZXJyb3IpID0+IHtcbiAgICBjb25zdCBtc2c6IEVycm9yTWVzc2FnZSA9IHtcbiAgICAgIGtpbmQ6ICdlcnJvcicsXG4gICAgICBkYXRhOiB7IGVycm9yOiBuZXcgRXJyb3IoYCR7Q3J5cHRvckVycm9yUmVhc29uW2Vycm9yLnJlYXNvbl19OiAke2Vycm9yLm1lc3NhZ2V9YCkgfSxcbiAgICB9O1xuICAgIHBvc3RNZXNzYWdlKG1zZyk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBlbWl0UmF0Y2hldGVkS2V5cyhtYXRlcmlhbDogQ3J5cHRvS2V5LCBwYXJ0aWNpcGFudElkZW50aXR5OiBzdHJpbmcsIGtleUluZGV4PzogbnVtYmVyKSB7XG4gIGNvbnN0IG1zZzogUmF0Y2hldE1lc3NhZ2UgPSB7XG4gICAga2luZDogYHJhdGNoZXRLZXlgLFxuICAgIGRhdGE6IHtcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHksXG4gICAgICBrZXlJbmRleCxcbiAgICAgIG1hdGVyaWFsLFxuICAgIH0sXG4gIH07XG4gIHBvc3RNZXNzYWdlKG1zZyk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVNpZlRyYWlsZXIodHJhaWxlcjogVWludDhBcnJheSkge1xuICBzaWZUcmFpbGVyID0gdHJhaWxlcjtcbiAgcGFydGljaXBhbnRDcnlwdG9ycy5mb3JFYWNoKChjKSA9PiB7XG4gICAgYy5zZXRTaWZUcmFpbGVyKHRyYWlsZXIpO1xuICB9KTtcbn1cblxuLy8gT3BlcmF0aW9ucyB1c2luZyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0uXG4vLyBAdHMtaWdub3JlXG5pZiAoc2VsZi5SVENUcmFuc2Zvcm1FdmVudCkge1xuICB3b3JrZXJMb2dnZXIuZGVidWcoJ3NldHVwIHRyYW5zZm9ybSBldmVudCcpO1xuICAvLyBAdHMtaWdub3JlXG4gIHNlbGYub25ydGN0cmFuc2Zvcm0gPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGV2ZW50LnRyYW5zZm9ybWVyO1xuICAgIHdvcmtlckxvZ2dlci5kZWJ1ZygndHJhbnNmb3JtZXInLCB0cmFuc2Zvcm1lcik7XG4gICAgdHJhbnNmb3JtZXIuaGFuZGxlZCA9IHRydWU7XG4gICAgY29uc3QgeyBraW5kLCBwYXJ0aWNpcGFudElkZW50aXR5LCB0cmFja0lkLCBjb2RlYyB9ID0gdHJhbnNmb3JtZXIub3B0aW9ucztcbiAgICBjb25zdCBjcnlwdG9yID0gZ2V0VHJhY2tDcnlwdG9yKHBhcnRpY2lwYW50SWRlbnRpdHksIHRyYWNrSWQpO1xuICAgIHdvcmtlckxvZ2dlci5kZWJ1ZygndHJhbnNmb3JtJywgeyBjb2RlYyB9KTtcbiAgICBjcnlwdG9yLnNldHVwVHJhbnNmb3JtKGtpbmQsIHRyYW5zZm9ybWVyLnJlYWRhYmxlLCB0cmFuc2Zvcm1lci53cml0YWJsZSwgdHJhY2tJZCwgY29kZWMpO1xuICB9O1xufVxuIl0sIm5hbWVzIjpbInJvb3QiLCJkZWZpbml0aW9uIiwibW9kdWxlIiwiZXhwb3J0cyIsImxvZyIsInRoaXMiLCJub29wIiwidW5kZWZpbmVkVHlwZSIsImlzSUUiLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJ0ZXN0IiwidXNlckFnZW50IiwibG9nTWV0aG9kcyIsImJpbmRNZXRob2QiLCJvYmoiLCJtZXRob2ROYW1lIiwibWV0aG9kIiwiYmluZCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiY2FsbCIsImUiLCJhcHBseSIsImFyZ3VtZW50cyIsInRyYWNlRm9ySUUiLCJjb25zb2xlIiwidHJhY2UiLCJyZWFsTWV0aG9kIiwidW5kZWZpbmVkIiwicmVwbGFjZUxvZ2dpbmdNZXRob2RzIiwibGV2ZWwiLCJsb2dnZXJOYW1lIiwiaSIsImxlbmd0aCIsIm1ldGhvZEZhY3RvcnkiLCJkZWJ1ZyIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIkxvZ2dlciIsIm5hbWUiLCJkZWZhdWx0TGV2ZWwiLCJmYWN0b3J5Iiwic2VsZiIsImN1cnJlbnRMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJ0b1VwcGVyQ2FzZSIsImxvY2FsU3RvcmFnZSIsImlnbm9yZSIsImRvY3VtZW50IiwiY29va2llIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiZ2V0UGVyc2lzdGVkTGV2ZWwiLCJzdG9yZWRMZXZlbCIsImxvY2F0aW9uIiwiaW5kZXhPZiIsImV4ZWMiLCJzbGljZSIsImxldmVscyIsImNsZWFyUGVyc2lzdGVkTGV2ZWwiLCJyZW1vdmVJdGVtIiwiZ2V0TGV2ZWwiLCJzZXRMZXZlbCIsInBlcnNpc3QiLCJTSUxFTlQiLCJzZXREZWZhdWx0TGV2ZWwiLCJyZXNldExldmVsIiwiZW5hYmxlQWxsIiwiVFJBQ0UiLCJkaXNhYmxlQWxsIiwiaW5pdGlhbExldmVsIiwiZGVmYXVsdExvZ2dlciIsIl9sb2dnZXJzQnlOYW1lIiwiZ2V0TG9nZ2VyIiwiVHlwZUVycm9yIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIiwiTG9nTGV2ZWwiLCJsaXZla2l0TG9nZ2VyIiwiaW5mbyIsIndvcmtlckxvZ2dlciIsIkVOQ1JZUFRJT05fQUxHT1JJVEhNIiwiS0VZUklOR19TSVpFIiwiREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSIsIlVORU5DUllQVEVEX0JZVEVTIiwia2V5IiwiZGVsdGEiLCJhdWRpbyIsImVtcHR5IiwiSVZfTEVOR1RIIiwiU0FMVCIsIktFWV9QUk9WSURFUl9ERUZBVUxUUyIsInNoYXJlZEtleSIsInJhdGNoZXRTYWx0IiwicmF0Y2hldFdpbmRvd1NpemUiLCJmYWlsdXJlVG9sZXJhbmNlIiwiTUFYX1NJRl9DT1VOVCIsIk1BWF9TSUZfRFVSQVRJT04iLCJMaXZla2l0RXJyb3IiLCJFcnJvciIsImNvbnN0cnVjdG9yIiwiY29kZSIsIm1lc3NhZ2UiLCJNZWRpYURldmljZUZhaWx1cmUiLCJnZXRGYWlsdXJlIiwiZXJyb3IiLCJOb3RGb3VuZCIsIlBlcm1pc3Npb25EZW5pZWQiLCJEZXZpY2VJblVzZSIsIk90aGVyIiwiQ3J5cHRvckVycm9yUmVhc29uIiwiQ3J5cHRvckVycm9yIiwicmVhc29uIiwiSW50ZXJuYWxFcnJvciIsIktleVByb3ZpZGVyRXZlbnQiLCJLZXlIYW5kbGVyRXZlbnQiLCJFbmNyeXB0aW9uRXZlbnQiLCJDcnlwdG9yRXZlbnQiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInRhcmdldCIsInJlY2VpdmVyIiwiYXJncyIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsIk9iamVjdCIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJjb25jYXQiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwid2FybiIsIk51bWJlcklzTmFOIiwiTnVtYmVyIiwiaXNOYU4iLCJ2YWx1ZSIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJldmVudHNNb2R1bGUiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0Iiwic2V0IiwiYXJnIiwiUmFuZ2VFcnJvciIsImdldFByb3RvdHlwZU9mIiwiY3JlYXRlIiwic2V0TWF4TGlzdGVuZXJzIiwibiIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJ0aGF0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdCIsInR5cGUiLCJwdXNoIiwiZG9FcnJvciIsImV2ZW50cyIsImVyIiwiZXJyIiwiY29udGV4dCIsImhhbmRsZXIiLCJsZW4iLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsIm0iLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwidW5zaGlmdCIsIndhcm5lZCIsInciLCJTdHJpbmciLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3QiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzaGlmdCIsInNwbGljZU9uZSIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsImtleXMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiYXJyIiwiY29weSIsIkFycmF5IiwiaW5kZXgiLCJwb3AiLCJyZXQiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJhZGRFdmVudExpc3RlbmVyIiwid3JhcExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsIm1heEJpdHJhdGUiLCJzcGVlY2giLCJtdXNpYyIsIm11c2ljU3RlcmVvIiwibXVzaWNIaWdoUXVhbGl0eSIsIm11c2ljSGlnaFF1YWxpdHlTdGVyZW8iLCJpc1ZpZGVvRnJhbWUiLCJmcmFtZSIsImltcG9ydEtleSIsImtleUJ5dGVzIiwiYWxnb3JpdGhtIiwidXNhZ2UiLCJjcnlwdG8iLCJzdWJ0bGUiLCJnZXRBbGdvT3B0aW9ucyIsImFsZ29yaXRobU5hbWUiLCJzYWx0IiwidGV4dEVuY29kZXIiLCJUZXh0RW5jb2RlciIsImVuY29kZWRTYWx0IiwiZW5jb2RlIiwiaGFzaCIsIkFycmF5QnVmZmVyIiwiaXRlcmF0aW9ucyIsImRlcml2ZUtleXMiLCJtYXRlcmlhbCIsImFsZ29yaXRobU9wdGlvbnMiLCJlbmNyeXB0aW9uS2V5IiwiZGVyaXZlS2V5IiwicmF0Y2hldCIsImRlcml2ZUJpdHMiLCJTaWZHdWFyZCIsImNvbnNlY3V0aXZlU2lmQ291bnQiLCJsYXN0U2lmUmVjZWl2ZWRBdCIsInVzZXJGcmFtZXNTaW5jZVNpZiIsInJlY29yZFNpZiIsIl9hIiwic2lmU2VxdWVuY2VTdGFydGVkQXQiLCJEYXRlIiwibm93IiwicmVjb3JkVXNlckZyYW1lIiwicmVzZXQiLCJpc1NpZkFsbG93ZWQiLCJlbmNyeXB0aW9uRW5hYmxlZE1hcCIsIk1hcCIsIkJhc2VGcmFtZUNyeXB0b3IiLCJlbmNvZGVGdW5jdGlvbiIsImVuY29kZWRGcmFtZSIsImNvbnRyb2xsZXIiLCJkZWNvZGVGdW5jdGlvbiIsIkZyYW1lQ3J5cHRvciIsIm9wdHMiLCJzZW5kQ291bnRzIiwicGFydGljaXBhbnRJZGVudGl0eSIsInJ0cE1hcCIsImtleVByb3ZpZGVyT3B0aW9ucyIsInNpZlRyYWlsZXIiLCJVaW50OEFycmF5IiwiZnJvbSIsInNpZkd1YXJkIiwic2V0UGFydGljaXBhbnQiLCJpZCIsInVuc2V0UGFydGljaXBhbnQiLCJpc0VuYWJsZWQiLCJnZXRQYXJ0aWNpcGFudElkZW50aXR5IiwiZ2V0VHJhY2tJZCIsInRyYWNrSWQiLCJzZXRWaWRlb0NvZGVjIiwiY29kZWMiLCJ2aWRlb0NvZGVjIiwic2V0UnRwTWFwIiwibWFwIiwic2V0dXBUcmFuc2Zvcm0iLCJvcGVyYXRpb24iLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwidHJhbnNmb3JtRm4iLCJ0cmFuc2Zvcm1TdHJlYW0iLCJUcmFuc2Zvcm1TdHJlYW0iLCJ0cmFuc2Zvcm0iLCJwaXBlVGhyb3VnaCIsInBpcGVUbyIsImNhdGNoIiwic2V0U2lmVHJhaWxlciIsInRyYWlsZXIiLCJkYXRhIiwiYnl0ZUxlbmd0aCIsImVucXVldWUiLCJrZXlTZXQiLCJnZXRLZXlTZXQiLCJnZXRDdXJyZW50S2V5SW5kZXgiLCJrZXlJbmRleCIsIml2IiwibWFrZUlWIiwiZ2V0TWV0YWRhdGEiLCJzeW5jaHJvbml6YXRpb25Tb3VyY2UiLCJ0aW1lc3RhbXAiLCJmcmFtZUhlYWRlciIsImdldFVuZW5jcnlwdGVkQnl0ZXMiLCJmcmFtZVRyYWlsZXIiLCJjaXBoZXJUZXh0IiwiZW5jcnlwdCIsImFkZGl0aW9uYWxEYXRhIiwibmV3RGF0YSIsIm5ld1VpbnQ4IiwiTWlzc2luZ0tleSIsImlzRnJhbWVTZXJ2ZXJJbmplY3RlZCIsImhhc1ZhbGlkS2V5IiwiZGVjb2RlZEZyYW1lIiwiZGVjcnlwdEZyYW1lIiwiZGVjcnlwdGlvblN1Y2Nlc3MiLCJJbnZhbGlkS2V5IiwiZGVjcnlwdGlvbkZhaWx1cmUiLCJpbml0aWFsTWF0ZXJpYWwiLCJyYXRjaGV0T3B0cyIsInJhdGNoZXRDb3VudCIsIml2TGVuZ3RoIiwiY2lwaGVyVGV4dFN0YXJ0IiwiY2lwaGVyVGV4dExlbmd0aCIsInBsYWluVGV4dCIsImRlY3J5cHQiLCJSVENFbmNvZGVkQXVkaW9GcmFtZSIsInJhdGNoZXRlZEtleVNldCIsIm5ld01hdGVyaWFsIiwicmF0Y2hldEtleSIsInNldEtleVNldCIsInNldEN1cnJlbnRLZXlJbmRleCIsInNldEtleUZyb21NYXRlcmlhbCIsIml2VmlldyIsIkRhdGFWaWV3IiwiaGFzIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwic2VuZENvdW50Iiwic2V0VWludDMyIiwiZGV0ZWN0ZWRDb2RlYyIsImdldFZpZGVvQ29kZWMiLCJuYWx1SW5kaWNlcyIsImZpbmROQUxVSW5kaWNlcyIsImlzSDI2NCIsInNvbWUiLCJuYWx1SW5kZXgiLCJOQUxVVHlwZSIsIlNMSUNFX0lEUiIsIlNMSUNFX05PTl9JRFIiLCJpbmNsdWRlcyIsInBhcnNlTkFMVVR5cGUiLCJzaXplIiwicGF5bG9hZFR5cGUiLCJzdHJlYW0iLCJyZXN1bHQiLCJzdGFydCIsInBvcyIsInNlYXJjaExlbmd0aCIsImVuZCIsInN0YXJ0Qnl0ZSIsImtOYWx1VHlwZU1hc2siLCJmcmFtZURhdGEiLCJ0cmFpbGVyQnl0ZXMiLCJldmVyeSIsIlBhcnRpY2lwYW50S2V5SGFuZGxlciIsIl9oYXNWYWxpZEtleSIsImRlY3J5cHRpb25GYWlsdXJlQ291bnQiLCJjdXJyZW50S2V5SW5kZXgiLCJjcnlwdG9LZXlSaW5nIiwiZmlsbCIsInJhdGNoZXRQcm9taXNlTWFwIiwicmVzZXRLZXlTdGF0dXMiLCJzZXRLZXkiLCJleGlzdGluZ1Byb21pc2UiLCJyYXRjaGV0UHJvbWlzZSIsIl9fYXdhaXRlciIsImN1cnJlbnRNYXRlcmlhbCIsIktleVJhdGNoZXRlZCIsImRlbGV0ZSIsImVtaXRSYXRjaGV0RXZlbnQiLCJwYXJ0aWNpcGFudENyeXB0b3JzIiwicGFydGljaXBhbnRLZXlzIiwic2hhcmVkS2V5SGFuZGxlciIsImlzRW5jcnlwdGlvbkVuYWJsZWQiLCJ1c2VTaGFyZWRLZXkiLCJvbm1lc3NhZ2UiLCJldiIsImtpbmQiLCJhY2tNc2ciLCJlbmFibGVkIiwicG9zdE1lc3NhZ2UiLCJzZXRFbmNyeXB0aW9uRW5hYmxlZCIsImNyeXB0b3IiLCJnZXRUcmFja0NyeXB0b3IiLCJyZWFkYWJsZVN0cmVhbSIsIndyaXRhYmxlU3RyZWFtIiwicHViQ3J5cHRvciIsInNldFNoYXJlZEtleSIsImdldFBhcnRpY2lwYW50S2V5SGFuZGxlciIsInVuc2V0Q3J5cHRvclBhcnRpY2lwYW50IiwiZm9yRWFjaCIsImNyIiwiaGFuZGxlUmF0Y2hldFJlcXVlc3QiLCJoYW5kbGVTaWZUcmFpbGVyIiwia2V5SGFuZGxlciIsImdldFNoYXJlZEtleUhhbmRsZXIiLCJmaW5kIiwiYyIsInNldHVwQ3J5cHRvckVycm9yRXZlbnRzIiwiZW1pdFJhdGNoZXRlZEtleXMiLCJlbmFibGUiLCJtc2ciLCJSVENUcmFuc2Zvcm1FdmVudCIsIm9ucnRjdHJhbnNmb3JtIiwiZXZlbnQiLCJ0cmFuc2Zvcm1lciIsImhhbmRsZWQiLCJvcHRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs\n"));

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			if (cachedModule.error !== undefined) throw cachedModule.error;
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		var threw = true;
/******/ 		try {
/******/ 			var execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };
/******/ 			__webpack_require__.i.forEach(function(handler) { handler(execOptions); });
/******/ 			module = execOptions.module;
/******/ 			execOptions.factory.call(module.exports, module, module.exports, execOptions.require);
/******/ 			threw = false;
/******/ 		} finally {
/******/ 			if(threw) delete __webpack_module_cache__[moduleId];
/******/ 		}
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// expose the module execution interceptor
/******/ 	__webpack_require__.i = [];
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/get javascript update chunk filename */
/******/ 	!function() {
/******/ 		// This function allow to reference all chunks
/******/ 		__webpack_require__.hu = function(chunkId) {
/******/ 			// return url for filenames based on template
/******/ 			return "static/webpack/" + chunkId + "." + __webpack_require__.h() + ".hot-update.js";
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/get update manifest filename */
/******/ 	!function() {
/******/ 		__webpack_require__.hmrF = function() { return "static/webpack/" + __webpack_require__.h() + ".913968047766177d.hot-update.json"; };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/getFullHash */
/******/ 	!function() {
/******/ 		__webpack_require__.h = function() { return "adcbe11c98b06f6f"; }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types policy */
/******/ 	!function() {
/******/ 		var policy;
/******/ 		__webpack_require__.tt = function() {
/******/ 			// Create Trusted Type policy if Trusted Types are available and the policy doesn't exist yet.
/******/ 			if (policy === undefined) {
/******/ 				policy = {
/******/ 					createScript: function(script) { return script; },
/******/ 					createScriptURL: function(url) { return url; }
/******/ 				};
/******/ 				if (typeof trustedTypes !== "undefined" && trustedTypes.createPolicy) {
/******/ 					policy = trustedTypes.createPolicy("nextjs#bundler", policy);
/******/ 				}
/******/ 			}
/******/ 			return policy;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script */
/******/ 	!function() {
/******/ 		__webpack_require__.ts = function(script) { return __webpack_require__.tt().createScript(script); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/trusted types script url */
/******/ 	!function() {
/******/ 		__webpack_require__.tu = function(url) { return __webpack_require__.tt().createScriptURL(url); };
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hot module replacement */
/******/ 	!function() {
/******/ 		var currentModuleData = {};
/******/ 		var installedModules = __webpack_require__.c;
/******/ 		
/******/ 		// module and require creation
/******/ 		var currentChildModule;
/******/ 		var currentParents = [];
/******/ 		
/******/ 		// status
/******/ 		var registeredStatusHandlers = [];
/******/ 		var currentStatus = "idle";
/******/ 		
/******/ 		// while downloading
/******/ 		var blockingPromises = 0;
/******/ 		var blockingPromisesWaiting = [];
/******/ 		
/******/ 		// The update info
/******/ 		var currentUpdateApplyHandlers;
/******/ 		var queuedInvalidatedModules;
/******/ 		
/******/ 		// eslint-disable-next-line no-unused-vars
/******/ 		__webpack_require__.hmrD = currentModuleData;
/******/ 		
/******/ 		__webpack_require__.i.push(function (options) {
/******/ 			var module = options.module;
/******/ 			var require = createRequire(options.require, options.id);
/******/ 			module.hot = createModuleHotObject(options.id, module);
/******/ 			module.parents = currentParents;
/******/ 			module.children = [];
/******/ 			currentParents = [];
/******/ 			options.require = require;
/******/ 		});
/******/ 		
/******/ 		__webpack_require__.hmrC = {};
/******/ 		__webpack_require__.hmrI = {};
/******/ 		
/******/ 		function createRequire(require, moduleId) {
/******/ 			var me = installedModules[moduleId];
/******/ 			if (!me) return require;
/******/ 			var fn = function (request) {
/******/ 				if (me.hot.active) {
/******/ 					if (installedModules[request]) {
/******/ 						var parents = installedModules[request].parents;
/******/ 						if (parents.indexOf(moduleId) === -1) {
/******/ 							parents.push(moduleId);
/******/ 						}
/******/ 					} else {
/******/ 						currentParents = [moduleId];
/******/ 						currentChildModule = request;
/******/ 					}
/******/ 					if (me.children.indexOf(request) === -1) {
/******/ 						me.children.push(request);
/******/ 					}
/******/ 				} else {
/******/ 					console.warn(
/******/ 						"[HMR] unexpected require(" +
/******/ 							request +
/******/ 							") from disposed module " +
/******/ 							moduleId
/******/ 					);
/******/ 					currentParents = [];
/******/ 				}
/******/ 				return require(request);
/******/ 			};
/******/ 			var createPropertyDescriptor = function (name) {
/******/ 				return {
/******/ 					configurable: true,
/******/ 					enumerable: true,
/******/ 					get: function () {
/******/ 						return require[name];
/******/ 					},
/******/ 					set: function (value) {
/******/ 						require[name] = value;
/******/ 					}
/******/ 				};
/******/ 			};
/******/ 			for (var name in require) {
/******/ 				if (Object.prototype.hasOwnProperty.call(require, name) && name !== "e") {
/******/ 					Object.defineProperty(fn, name, createPropertyDescriptor(name));
/******/ 				}
/******/ 			}
/******/ 			fn.e = function (chunkId) {
/******/ 				return trackBlockingPromise(require.e(chunkId));
/******/ 			};
/******/ 			return fn;
/******/ 		}
/******/ 		
/******/ 		function createModuleHotObject(moduleId, me) {
/******/ 			var _main = currentChildModule !== moduleId;
/******/ 			var hot = {
/******/ 				// private stuff
/******/ 				_acceptedDependencies: {},
/******/ 				_acceptedErrorHandlers: {},
/******/ 				_declinedDependencies: {},
/******/ 				_selfAccepted: false,
/******/ 				_selfDeclined: false,
/******/ 				_selfInvalidated: false,
/******/ 				_disposeHandlers: [],
/******/ 				_main: _main,
/******/ 				_requireSelf: function () {
/******/ 					currentParents = me.parents.slice();
/******/ 					currentChildModule = _main ? undefined : moduleId;
/******/ 					__webpack_require__(moduleId);
/******/ 				},
/******/ 		
/******/ 				// Module API
/******/ 				active: true,
/******/ 				accept: function (dep, callback, errorHandler) {
/******/ 					if (dep === undefined) hot._selfAccepted = true;
/******/ 					else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 					else if (typeof dep === "object" && dep !== null) {
/******/ 						for (var i = 0; i < dep.length; i++) {
/******/ 							hot._acceptedDependencies[dep[i]] = callback || function () {};
/******/ 							hot._acceptedErrorHandlers[dep[i]] = errorHandler;
/******/ 						}
/******/ 					} else {
/******/ 						hot._acceptedDependencies[dep] = callback || function () {};
/******/ 						hot._acceptedErrorHandlers[dep] = errorHandler;
/******/ 					}
/******/ 				},
/******/ 				decline: function (dep) {
/******/ 					if (dep === undefined) hot._selfDeclined = true;
/******/ 					else if (typeof dep === "object" && dep !== null)
/******/ 						for (var i = 0; i < dep.length; i++)
/******/ 							hot._declinedDependencies[dep[i]] = true;
/******/ 					else hot._declinedDependencies[dep] = true;
/******/ 				},
/******/ 				dispose: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				addDisposeHandler: function (callback) {
/******/ 					hot._disposeHandlers.push(callback);
/******/ 				},
/******/ 				removeDisposeHandler: function (callback) {
/******/ 					var idx = hot._disposeHandlers.indexOf(callback);
/******/ 					if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 				},
/******/ 				invalidate: function () {
/******/ 					this._selfInvalidated = true;
/******/ 					switch (currentStatus) {
/******/ 						case "idle":
/******/ 							currentUpdateApplyHandlers = [];
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							setStatus("ready");
/******/ 							break;
/******/ 						case "ready":
/******/ 							Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 								__webpack_require__.hmrI[key](
/******/ 									moduleId,
/******/ 									currentUpdateApplyHandlers
/******/ 								);
/******/ 							});
/******/ 							break;
/******/ 						case "prepare":
/******/ 						case "check":
/******/ 						case "dispose":
/******/ 						case "apply":
/******/ 							(queuedInvalidatedModules = queuedInvalidatedModules || []).push(
/******/ 								moduleId
/******/ 							);
/******/ 							break;
/******/ 						default:
/******/ 							// ignore requests in error states
/******/ 							break;
/******/ 					}
/******/ 				},
/******/ 		
/******/ 				// Management API
/******/ 				check: hotCheck,
/******/ 				apply: hotApply,
/******/ 				status: function (l) {
/******/ 					if (!l) return currentStatus;
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				addStatusHandler: function (l) {
/******/ 					registeredStatusHandlers.push(l);
/******/ 				},
/******/ 				removeStatusHandler: function (l) {
/******/ 					var idx = registeredStatusHandlers.indexOf(l);
/******/ 					if (idx >= 0) registeredStatusHandlers.splice(idx, 1);
/******/ 				},
/******/ 		
/******/ 				//inherit from previous dispose call
/******/ 				data: currentModuleData[moduleId]
/******/ 			};
/******/ 			currentChildModule = undefined;
/******/ 			return hot;
/******/ 		}
/******/ 		
/******/ 		function setStatus(newStatus) {
/******/ 			currentStatus = newStatus;
/******/ 			var results = [];
/******/ 		
/******/ 			for (var i = 0; i < registeredStatusHandlers.length; i++)
/******/ 				results[i] = registeredStatusHandlers[i].call(null, newStatus);
/******/ 		
/******/ 			return Promise.all(results);
/******/ 		}
/******/ 		
/******/ 		function unblock() {
/******/ 			if (--blockingPromises === 0) {
/******/ 				setStatus("ready").then(function () {
/******/ 					if (blockingPromises === 0) {
/******/ 						var list = blockingPromisesWaiting;
/******/ 						blockingPromisesWaiting = [];
/******/ 						for (var i = 0; i < list.length; i++) {
/******/ 							list[i]();
/******/ 						}
/******/ 					}
/******/ 				});
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function trackBlockingPromise(promise) {
/******/ 			switch (currentStatus) {
/******/ 				case "ready":
/******/ 					setStatus("prepare");
/******/ 				/* fallthrough */
/******/ 				case "prepare":
/******/ 					blockingPromises++;
/******/ 					promise.then(unblock, unblock);
/******/ 					return promise;
/******/ 				default:
/******/ 					return promise;
/******/ 			}
/******/ 		}
/******/ 		
/******/ 		function waitForBlockingPromises(fn) {
/******/ 			if (blockingPromises === 0) return fn();
/******/ 			return new Promise(function (resolve) {
/******/ 				blockingPromisesWaiting.push(function () {
/******/ 					resolve(fn());
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function hotCheck(applyOnUpdate) {
/******/ 			if (currentStatus !== "idle") {
/******/ 				throw new Error("check() is only allowed in idle status");
/******/ 			}
/******/ 			return setStatus("check")
/******/ 				.then(__webpack_require__.hmrM)
/******/ 				.then(function (update) {
/******/ 					if (!update) {
/******/ 						return setStatus(applyInvalidatedModules() ? "ready" : "idle").then(
/******/ 							function () {
/******/ 								return null;
/******/ 							}
/******/ 						);
/******/ 					}
/******/ 		
/******/ 					return setStatus("prepare").then(function () {
/******/ 						var updatedModules = [];
/******/ 						currentUpdateApplyHandlers = [];
/******/ 		
/******/ 						return Promise.all(
/******/ 							Object.keys(__webpack_require__.hmrC).reduce(function (
/******/ 								promises,
/******/ 								key
/******/ 							) {
/******/ 								__webpack_require__.hmrC[key](
/******/ 									update.c,
/******/ 									update.r,
/******/ 									update.m,
/******/ 									promises,
/******/ 									currentUpdateApplyHandlers,
/******/ 									updatedModules
/******/ 								);
/******/ 								return promises;
/******/ 							},
/******/ 							[])
/******/ 						).then(function () {
/******/ 							return waitForBlockingPromises(function () {
/******/ 								if (applyOnUpdate) {
/******/ 									return internalApply(applyOnUpdate);
/******/ 								} else {
/******/ 									return setStatus("ready").then(function () {
/******/ 										return updatedModules;
/******/ 									});
/******/ 								}
/******/ 							});
/******/ 						});
/******/ 					});
/******/ 				});
/******/ 		}
/******/ 		
/******/ 		function hotApply(options) {
/******/ 			if (currentStatus !== "ready") {
/******/ 				return Promise.resolve().then(function () {
/******/ 					throw new Error(
/******/ 						"apply() is only allowed in ready status (state: " +
/******/ 							currentStatus +
/******/ 							")"
/******/ 					);
/******/ 				});
/******/ 			}
/******/ 			return internalApply(options);
/******/ 		}
/******/ 		
/******/ 		function internalApply(options) {
/******/ 			options = options || {};
/******/ 		
/******/ 			applyInvalidatedModules();
/******/ 		
/******/ 			var results = currentUpdateApplyHandlers.map(function (handler) {
/******/ 				return handler(options);
/******/ 			});
/******/ 			currentUpdateApplyHandlers = undefined;
/******/ 		
/******/ 			var errors = results
/******/ 				.map(function (r) {
/******/ 					return r.error;
/******/ 				})
/******/ 				.filter(Boolean);
/******/ 		
/******/ 			if (errors.length > 0) {
/******/ 				return setStatus("abort").then(function () {
/******/ 					throw errors[0];
/******/ 				});
/******/ 			}
/******/ 		
/******/ 			// Now in "dispose" phase
/******/ 			var disposePromise = setStatus("dispose");
/******/ 		
/******/ 			results.forEach(function (result) {
/******/ 				if (result.dispose) result.dispose();
/******/ 			});
/******/ 		
/******/ 			// Now in "apply" phase
/******/ 			var applyPromise = setStatus("apply");
/******/ 		
/******/ 			var error;
/******/ 			var reportError = function (err) {
/******/ 				if (!error) error = err;
/******/ 			};
/******/ 		
/******/ 			var outdatedModules = [];
/******/ 			results.forEach(function (result) {
/******/ 				if (result.apply) {
/******/ 					var modules = result.apply(reportError);
/******/ 					if (modules) {
/******/ 						for (var i = 0; i < modules.length; i++) {
/******/ 							outdatedModules.push(modules[i]);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			});
/******/ 		
/******/ 			return Promise.all([disposePromise, applyPromise]).then(function () {
/******/ 				// handle errors in accept handlers and self accepted module load
/******/ 				if (error) {
/******/ 					return setStatus("fail").then(function () {
/******/ 						throw error;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				if (queuedInvalidatedModules) {
/******/ 					return internalApply(options).then(function (list) {
/******/ 						outdatedModules.forEach(function (moduleId) {
/******/ 							if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 						});
/******/ 						return list;
/******/ 					});
/******/ 				}
/******/ 		
/******/ 				return setStatus("idle").then(function () {
/******/ 					return outdatedModules;
/******/ 				});
/******/ 			});
/******/ 		}
/******/ 		
/******/ 		function applyInvalidatedModules() {
/******/ 			if (queuedInvalidatedModules) {
/******/ 				if (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];
/******/ 				Object.keys(__webpack_require__.hmrI).forEach(function (key) {
/******/ 					queuedInvalidatedModules.forEach(function (moduleId) {
/******/ 						__webpack_require__.hmrI[key](
/******/ 							moduleId,
/******/ 							currentUpdateApplyHandlers
/******/ 						);
/******/ 					});
/******/ 				});
/******/ 				queuedInvalidatedModules = undefined;
/******/ 				return true;
/******/ 			}
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	!function() {
/******/ 		__webpack_require__.p = "/_next/";
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/react refresh */
/******/ 	!function() {
/******/ 		if (__webpack_require__.i) {
/******/ 		__webpack_require__.i.push(function(options) {
/******/ 			var originalFactory = options.factory;
/******/ 			options.factory = function(moduleObject, moduleExports, webpackRequire) {
/******/ 				var hasRefresh = typeof self !== "undefined" && !!self.$RefreshInterceptModuleExecution$;
/******/ 				var cleanup = hasRefresh ? self.$RefreshInterceptModuleExecution$(moduleObject.id) : function() {};
/******/ 				try {
/******/ 					originalFactory.call(this, moduleObject, moduleExports, webpackRequire);
/******/ 				} finally {
/******/ 					cleanup();
/******/ 				}
/******/ 			}
/******/ 		})
/******/ 		}
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat */
/******/ 	
/******/ 	
/******/ 	// noop fns to prevent runtime errors during initialization
/******/ 	if (typeof self !== "undefined") {
/******/ 		self.$RefreshReg$ = function () {};
/******/ 		self.$RefreshSig$ = function () {
/******/ 			return function (type) {
/******/ 				return type;
/******/ 			};
/******/ 		};
/******/ 	}
/******/ 	
/******/ 	/* webpack/runtime/importScripts chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "already loaded"
/******/ 		var installedChunks = __webpack_require__.hmrS_importScripts = __webpack_require__.hmrS_importScripts || {
/******/ 			"node_modules_livekit-client_dist_livekit-client_e2ee_worker_mjs": 1
/******/ 		};
/******/ 		
/******/ 		// no chunk install function needed
/******/ 		// no chunk loading
/******/ 		
/******/ 		function loadUpdateChunk(chunkId, updatedModulesList) {
/******/ 			var success = false;
/******/ 			self["webpackHotUpdate_N_E"] = function(_, moreModules, runtime) {
/******/ 				for(var moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						currentUpdate[moduleId] = moreModules[moduleId];
/******/ 						if(updatedModulesList) updatedModulesList.push(moduleId);
/******/ 					}
/******/ 				}
/******/ 				if(runtime) currentUpdateRuntime.push(runtime);
/******/ 				success = true;
/******/ 			};
/******/ 			// start update chunk loading
/******/ 			importScripts(__webpack_require__.tu(__webpack_require__.p + __webpack_require__.hu(chunkId)));
/******/ 			if(!success) throw new Error("Loading update chunk failed for unknown reason");
/******/ 		}
/******/ 		
/******/ 		var currentUpdateChunks;
/******/ 		var currentUpdate;
/******/ 		var currentUpdateRemovedChunks;
/******/ 		var currentUpdateRuntime;
/******/ 		function applyHandler(options) {
/******/ 			if (__webpack_require__.f) delete __webpack_require__.f.importScripsHmr;
/******/ 			currentUpdateChunks = undefined;
/******/ 			function getAffectedModuleEffects(updateModuleId) {
/******/ 				var outdatedModules = [updateModuleId];
/******/ 				var outdatedDependencies = {};
/******/ 		
/******/ 				var queue = outdatedModules.map(function (id) {
/******/ 					return {
/******/ 						chain: [id],
/******/ 						id: id
/******/ 					};
/******/ 				});
/******/ 				while (queue.length > 0) {
/******/ 					var queueItem = queue.pop();
/******/ 					var moduleId = queueItem.id;
/******/ 					var chain = queueItem.chain;
/******/ 					var module = __webpack_require__.c[moduleId];
/******/ 					if (
/******/ 						!module ||
/******/ 						(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 					)
/******/ 						continue;
/******/ 					if (module.hot._selfDeclined) {
/******/ 						return {
/******/ 							type: "self-declined",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					if (module.hot._main) {
/******/ 						return {
/******/ 							type: "unaccepted",
/******/ 							chain: chain,
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					for (var i = 0; i < module.parents.length; i++) {
/******/ 						var parentId = module.parents[i];
/******/ 						var parent = __webpack_require__.c[parentId];
/******/ 						if (!parent) continue;
/******/ 						if (parent.hot._declinedDependencies[moduleId]) {
/******/ 							return {
/******/ 								type: "declined",
/******/ 								chain: chain.concat([parentId]),
/******/ 								moduleId: moduleId,
/******/ 								parentId: parentId
/******/ 							};
/******/ 						}
/******/ 						if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 						if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 							if (!outdatedDependencies[parentId])
/******/ 								outdatedDependencies[parentId] = [];
/******/ 							addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 							continue;
/******/ 						}
/******/ 						delete outdatedDependencies[parentId];
/******/ 						outdatedModules.push(parentId);
/******/ 						queue.push({
/******/ 							chain: chain.concat([parentId]),
/******/ 							id: parentId
/******/ 						});
/******/ 					}
/******/ 				}
/******/ 		
/******/ 				return {
/******/ 					type: "accepted",
/******/ 					moduleId: updateModuleId,
/******/ 					outdatedModules: outdatedModules,
/******/ 					outdatedDependencies: outdatedDependencies
/******/ 				};
/******/ 			}
/******/ 		
/******/ 			function addAllToSet(a, b) {
/******/ 				for (var i = 0; i < b.length; i++) {
/******/ 					var item = b[i];
/******/ 					if (a.indexOf(item) === -1) a.push(item);
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			// at begin all updates modules are outdated
/******/ 			// the "outdated" status can propagate to parents if they don't accept the children
/******/ 			var outdatedDependencies = {};
/******/ 			var outdatedModules = [];
/******/ 			var appliedUpdate = {};
/******/ 		
/******/ 			var warnUnexpectedRequire = function warnUnexpectedRequire(module) {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" + module.id + ") to disposed module"
/******/ 				);
/******/ 			};
/******/ 		
/******/ 			for (var moduleId in currentUpdate) {
/******/ 				if (__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 					var newModuleFactory = currentUpdate[moduleId];
/******/ 					/** @type {TODO} */
/******/ 					var result;
/******/ 					if (newModuleFactory) {
/******/ 						result = getAffectedModuleEffects(moduleId);
/******/ 					} else {
/******/ 						result = {
/******/ 							type: "disposed",
/******/ 							moduleId: moduleId
/******/ 						};
/******/ 					}
/******/ 					/** @type {Error|false} */
/******/ 					var abortError = false;
/******/ 					var doApply = false;
/******/ 					var doDispose = false;
/******/ 					var chainInfo = "";
/******/ 					if (result.chain) {
/******/ 						chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 					}
/******/ 					switch (result.type) {
/******/ 						case "self-declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of self decline: " +
/******/ 										result.moduleId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "declined":
/******/ 							if (options.onDeclined) options.onDeclined(result);
/******/ 							if (!options.ignoreDeclined)
/******/ 								abortError = new Error(
/******/ 									"Aborted because of declined dependency: " +
/******/ 										result.moduleId +
/******/ 										" in " +
/******/ 										result.parentId +
/******/ 										chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "unaccepted":
/******/ 							if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 							if (!options.ignoreUnaccepted)
/******/ 								abortError = new Error(
/******/ 									"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 								);
/******/ 							break;
/******/ 						case "accepted":
/******/ 							if (options.onAccepted) options.onAccepted(result);
/******/ 							doApply = true;
/******/ 							break;
/******/ 						case "disposed":
/******/ 							if (options.onDisposed) options.onDisposed(result);
/******/ 							doDispose = true;
/******/ 							break;
/******/ 						default:
/******/ 							throw new Error("Unexception type " + result.type);
/******/ 					}
/******/ 					if (abortError) {
/******/ 						return {
/******/ 							error: abortError
/******/ 						};
/******/ 					}
/******/ 					if (doApply) {
/******/ 						appliedUpdate[moduleId] = newModuleFactory;
/******/ 						addAllToSet(outdatedModules, result.outdatedModules);
/******/ 						for (moduleId in result.outdatedDependencies) {
/******/ 							if (__webpack_require__.o(result.outdatedDependencies, moduleId)) {
/******/ 								if (!outdatedDependencies[moduleId])
/******/ 									outdatedDependencies[moduleId] = [];
/******/ 								addAllToSet(
/******/ 									outdatedDependencies[moduleId],
/******/ 									result.outdatedDependencies[moduleId]
/******/ 								);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 					if (doDispose) {
/******/ 						addAllToSet(outdatedModules, [result.moduleId]);
/******/ 						appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 			currentUpdate = undefined;
/******/ 		
/******/ 			// Store self accepted outdated modules to require them later by the module system
/******/ 			var outdatedSelfAcceptedModules = [];
/******/ 			for (var j = 0; j < outdatedModules.length; j++) {
/******/ 				var outdatedModuleId = outdatedModules[j];
/******/ 				var module = __webpack_require__.c[outdatedModuleId];
/******/ 				if (
/******/ 					module &&
/******/ 					(module.hot._selfAccepted || module.hot._main) &&
/******/ 					// removed self-accepted modules should not be required
/******/ 					appliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&
/******/ 					// when called invalidate self-accepting is not possible
/******/ 					!module.hot._selfInvalidated
/******/ 				) {
/******/ 					outdatedSelfAcceptedModules.push({
/******/ 						module: outdatedModuleId,
/******/ 						require: module.hot._requireSelf,
/******/ 						errorHandler: module.hot._selfAccepted
/******/ 					});
/******/ 				}
/******/ 			}
/******/ 		
/******/ 			var moduleOutdatedDependencies;
/******/ 		
/******/ 			return {
/******/ 				dispose: function () {
/******/ 					currentUpdateRemovedChunks.forEach(function (chunkId) {
/******/ 						delete installedChunks[chunkId];
/******/ 					});
/******/ 					currentUpdateRemovedChunks = undefined;
/******/ 		
/******/ 					var idx;
/******/ 					var queue = outdatedModules.slice();
/******/ 					while (queue.length > 0) {
/******/ 						var moduleId = queue.pop();
/******/ 						var module = __webpack_require__.c[moduleId];
/******/ 						if (!module) continue;
/******/ 		
/******/ 						var data = {};
/******/ 		
/******/ 						// Call dispose handlers
/******/ 						var disposeHandlers = module.hot._disposeHandlers;
/******/ 						for (j = 0; j < disposeHandlers.length; j++) {
/******/ 							disposeHandlers[j].call(null, data);
/******/ 						}
/******/ 						__webpack_require__.hmrD[moduleId] = data;
/******/ 		
/******/ 						// disable module (this disables requires from this module)
/******/ 						module.hot.active = false;
/******/ 		
/******/ 						// remove module from cache
/******/ 						delete __webpack_require__.c[moduleId];
/******/ 		
/******/ 						// when disposing there is no need to call dispose handler
/******/ 						delete outdatedDependencies[moduleId];
/******/ 		
/******/ 						// remove "parents" references from all children
/******/ 						for (j = 0; j < module.children.length; j++) {
/******/ 							var child = __webpack_require__.c[module.children[j]];
/******/ 							if (!child) continue;
/******/ 							idx = child.parents.indexOf(moduleId);
/******/ 							if (idx >= 0) {
/******/ 								child.parents.splice(idx, 1);
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// remove outdated dependency from module children
/******/ 					var dependency;
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									dependency = moduleOutdatedDependencies[j];
/******/ 									idx = module.children.indexOf(dependency);
/******/ 									if (idx >= 0) module.children.splice(idx, 1);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				},
/******/ 				apply: function (reportError) {
/******/ 					// insert new code
/******/ 					for (var updateModuleId in appliedUpdate) {
/******/ 						if (__webpack_require__.o(appliedUpdate, updateModuleId)) {
/******/ 							__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// run new runtime modules
/******/ 					for (var i = 0; i < currentUpdateRuntime.length; i++) {
/******/ 						currentUpdateRuntime[i](__webpack_require__);
/******/ 					}
/******/ 		
/******/ 					// call accept handlers
/******/ 					for (var outdatedModuleId in outdatedDependencies) {
/******/ 						if (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {
/******/ 							var module = __webpack_require__.c[outdatedModuleId];
/******/ 							if (module) {
/******/ 								moduleOutdatedDependencies =
/******/ 									outdatedDependencies[outdatedModuleId];
/******/ 								var callbacks = [];
/******/ 								var errorHandlers = [];
/******/ 								var dependenciesForCallbacks = [];
/******/ 								for (var j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 									var dependency = moduleOutdatedDependencies[j];
/******/ 									var acceptCallback =
/******/ 										module.hot._acceptedDependencies[dependency];
/******/ 									var errorHandler =
/******/ 										module.hot._acceptedErrorHandlers[dependency];
/******/ 									if (acceptCallback) {
/******/ 										if (callbacks.indexOf(acceptCallback) !== -1) continue;
/******/ 										callbacks.push(acceptCallback);
/******/ 										errorHandlers.push(errorHandler);
/******/ 										dependenciesForCallbacks.push(dependency);
/******/ 									}
/******/ 								}
/******/ 								for (var k = 0; k < callbacks.length; k++) {
/******/ 									try {
/******/ 										callbacks[k].call(null, moduleOutdatedDependencies);
/******/ 									} catch (err) {
/******/ 										if (typeof errorHandlers[k] === "function") {
/******/ 											try {
/******/ 												errorHandlers[k](err, {
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k]
/******/ 												});
/******/ 											} catch (err2) {
/******/ 												if (options.onErrored) {
/******/ 													options.onErrored({
/******/ 														type: "accept-error-handler-errored",
/******/ 														moduleId: outdatedModuleId,
/******/ 														dependencyId: dependenciesForCallbacks[k],
/******/ 														error: err2,
/******/ 														originalError: err
/******/ 													});
/******/ 												}
/******/ 												if (!options.ignoreErrored) {
/******/ 													reportError(err2);
/******/ 													reportError(err);
/******/ 												}
/******/ 											}
/******/ 										} else {
/******/ 											if (options.onErrored) {
/******/ 												options.onErrored({
/******/ 													type: "accept-errored",
/******/ 													moduleId: outdatedModuleId,
/******/ 													dependencyId: dependenciesForCallbacks[k],
/******/ 													error: err
/******/ 												});
/******/ 											}
/******/ 											if (!options.ignoreErrored) {
/******/ 												reportError(err);
/******/ 											}
/******/ 										}
/******/ 									}
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					// Load self accepted modules
/******/ 					for (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {
/******/ 						var item = outdatedSelfAcceptedModules[o];
/******/ 						var moduleId = item.module;
/******/ 						try {
/******/ 							item.require(moduleId);
/******/ 						} catch (err) {
/******/ 							if (typeof item.errorHandler === "function") {
/******/ 								try {
/******/ 									item.errorHandler(err, {
/******/ 										moduleId: moduleId,
/******/ 										module: __webpack_require__.c[moduleId]
/******/ 									});
/******/ 								} catch (err2) {
/******/ 									if (options.onErrored) {
/******/ 										options.onErrored({
/******/ 											type: "self-accept-error-handler-errored",
/******/ 											moduleId: moduleId,
/******/ 											error: err2,
/******/ 											originalError: err
/******/ 										});
/******/ 									}
/******/ 									if (!options.ignoreErrored) {
/******/ 										reportError(err2);
/******/ 										reportError(err);
/******/ 									}
/******/ 								}
/******/ 							} else {
/******/ 								if (options.onErrored) {
/******/ 									options.onErrored({
/******/ 										type: "self-accept-errored",
/******/ 										moduleId: moduleId,
/******/ 										error: err
/******/ 									});
/******/ 								}
/******/ 								if (!options.ignoreErrored) {
/******/ 									reportError(err);
/******/ 								}
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 		
/******/ 					return outdatedModules;
/******/ 				}
/******/ 			};
/******/ 		}
/******/ 		__webpack_require__.hmrI.importScrips = function (moduleId, applyHandlers) {
/******/ 			if (!currentUpdate) {
/******/ 				currentUpdate = {};
/******/ 				currentUpdateRuntime = [];
/******/ 				currentUpdateRemovedChunks = [];
/******/ 				applyHandlers.push(applyHandler);
/******/ 			}
/******/ 			if (!__webpack_require__.o(currentUpdate, moduleId)) {
/******/ 				currentUpdate[moduleId] = __webpack_require__.m[moduleId];
/******/ 			}
/******/ 		};
/******/ 		__webpack_require__.hmrC.importScrips = function (
/******/ 			chunkIds,
/******/ 			removedChunks,
/******/ 			removedModules,
/******/ 			promises,
/******/ 			applyHandlers,
/******/ 			updatedModulesList
/******/ 		) {
/******/ 			applyHandlers.push(applyHandler);
/******/ 			currentUpdateChunks = {};
/******/ 			currentUpdateRemovedChunks = removedChunks;
/******/ 			currentUpdate = removedModules.reduce(function (obj, key) {
/******/ 				obj[key] = false;
/******/ 				return obj;
/******/ 			}, {});
/******/ 			currentUpdateRuntime = [];
/******/ 			chunkIds.forEach(function (chunkId) {
/******/ 				if (
/******/ 					__webpack_require__.o(installedChunks, chunkId) &&
/******/ 					installedChunks[chunkId] !== undefined
/******/ 				) {
/******/ 					promises.push(loadUpdateChunk(chunkId, updatedModulesList));
/******/ 					currentUpdateChunks[chunkId] = true;
/******/ 				} else {
/******/ 					currentUpdateChunks[chunkId] = false;
/******/ 				}
/******/ 			});
/******/ 			if (__webpack_require__.f) {
/******/ 				__webpack_require__.f.importScripsHmr = function (chunkId, promises) {
/******/ 					if (
/******/ 						currentUpdateChunks &&
/******/ 						__webpack_require__.o(currentUpdateChunks, chunkId) &&
/******/ 						!currentUpdateChunks[chunkId]
/******/ 					) {
/******/ 						promises.push(loadUpdateChunk(chunkId));
/******/ 						currentUpdateChunks[chunkId] = true;
/******/ 					}
/******/ 				};
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.hmrM = function() {
/******/ 			if (typeof fetch === "undefined") throw new Error("No browser support: need fetch API");
/******/ 			return fetch(__webpack_require__.p + __webpack_require__.hmrF()).then(function(response) {
/******/ 				if(response.status === 404) return; // no update available
/******/ 				if(!response.ok) throw new Error("Failed to fetch update manifest " + response.statusText);
/******/ 				return response.json();
/******/ 			});
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	var __webpack_exports__ = __webpack_require__("./node_modules/livekit-client/dist/livekit-client.e2ee.worker.mjs");
/******/ 	_N_E = __webpack_exports__;
/******/ 	
/******/ })()
;